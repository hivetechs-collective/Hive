import { app, BrowserWindow, ipcMain, Menu, dialog, MenuItem } from 'electron';

// Set the app name immediately
app.setName('Hive Consensus');

import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';
import { Database } from 'sqlite3';
import { spawn, ChildProcess } from 'child_process';
import { GitManager } from './git-manager';
import { GitManagerV2 } from './git-manager-v2';
import { FileSystemManager } from './file-system';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

let db: Database | null = null;
let mainWindow: BrowserWindow | null = null;

// Initialize SQLite database connection - use the existing hive-ai.db
const initDatabase = () => {
  // Use the actual Hive database location
  const dbPath = path.join(os.homedir(), '.hive', 'hive-ai.db');
  
  // Create .hive directory if it doesn't exist
  const hiveDir = path.join(os.homedir(), '.hive');
  if (!fs.existsSync(hiveDir)) {
    fs.mkdirSync(hiveDir, { recursive: true });
  }
  
  db = new Database(dbPath);
  
  // The database already exists with proper schema
  // Just ensure the configurations table exists (matching Rust implementation)
  db.run(`CREATE TABLE IF NOT EXISTS configurations (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    encrypted BOOLEAN DEFAULT 0,
    user_id TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
  )`);
  
  // Ensure users table exists with default user
  db.run(`CREATE TABLE IF NOT EXISTS users (
    id TEXT PRIMARY KEY,
    email TEXT,
    tier TEXT
  )`);
  
  // Insert default user if not exists
  db.run(`INSERT OR IGNORE INTO users (id, email, tier) VALUES ('default', 'default@hive.ai', 'FREE')`);
  
  // Create consensus_settings table for active profile
  db.run(`CREATE TABLE IF NOT EXISTS consensus_settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
  )`);
  
  // Create stage_outputs table to track model usage per stage
  db.run(`CREATE TABLE IF NOT EXISTS stage_outputs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    conversation_id TEXT NOT NULL,
    stage_name TEXT NOT NULL,
    model TEXT NOT NULL,
    tokens_used INTEGER DEFAULT 0,
    cost REAL DEFAULT 0,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (conversation_id) REFERENCES conversations(id)
  )`);
  
  // Keep consensus profiles table matching actual database schema
  db.run(`CREATE TABLE IF NOT EXISTS consensus_profiles (
    id TEXT PRIMARY KEY,
    profile_name TEXT NOT NULL,
    generator_model TEXT NOT NULL,
    refiner_model TEXT NOT NULL,
    validator_model TEXT NOT NULL,
    curator_model TEXT NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
  )`);
};

// Toggle this to switch between old and new implementation
const USE_NEW_GIT_MANAGER = false;

// Git Integration
let gitManager: GitManager | GitManagerV2 | null = null;

// Initialize Git manager - pass no path when no folder is open
const initGitManager = (folderPath?: string) => {
  if (USE_NEW_GIT_MANAGER) {
    console.log('[Main] Using new GitManagerV2 with VS Code-style implementation');
    gitManager = new GitManagerV2(folderPath);
  } else {
    console.log('[Main] Using old GitManager with simple-git');
    gitManager = new GitManager(folderPath);
  }
};

// File System Manager
let fileSystemManager: FileSystemManager | null = null;

// Initialize File System manager
const initFileSystemManager = () => {
  fileSystemManager = new FileSystemManager();
};

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    minWidth: 700, // Prevent window from becoming too small
    minHeight: 400,
    title: 'Hive Consensus',
    icon: path.join(__dirname, '../resources/icon.png'), // Icon for the window
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
      webSecurity: false, // Allow HTTP requests to localhost for development
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  // mainWindow.webContents.openDevTools(); // Disabled to prevent warning overlay
  
  // Register IPC handlers here after window creation
  registerGitHandlers();
  registerFileSystemHandlers();
  
  // Create application menu
  createApplicationMenu();
};

const registerGitHandlers = () => {
  // Git IPC handlers
  ipcMain.handle('git-status', async () => {
    if (!gitManager) initGitManager();
    return await gitManager!.getStatus();
  });

  ipcMain.handle('git-branches', async () => {
    if (!gitManager) initGitManager();
    return await gitManager!.getBranches();
  });

  ipcMain.handle('git-log', async (_, options?: { maxCount?: number; graph?: boolean; oneline?: boolean; limit?: number }) => {
    if (!gitManager) initGitManager();
    console.log('[Main] git-log called with options:', options);
    const result = await gitManager!.getLog(options || {});
    console.log('[Main] git-log returning:', result ? result.substring(0, 100) + '...' : 'empty');
    return result;
  });

  ipcMain.handle('git-diff', async (_, file?: string) => {
    if (!gitManager) initGitManager();
    return await gitManager!.getDiff(file);
  });

  ipcMain.handle('git-staged-diff', async (_, file?: string) => {
    if (!gitManager) initGitManager();
    return await gitManager!.getStagedDiff(file);
  });

  ipcMain.handle('git-stage', async (_, files: string[]) => {
    if (!gitManager) initGitManager();
    return await gitManager!.stage(files);
  });

  ipcMain.handle('git-unstage', async (_, files: string[]) => {
    if (!gitManager) initGitManager();
    return await gitManager!.unstage(files);
  });

  ipcMain.handle('git-commit', async (_, message: string) => {
    if (!gitManager) initGitManager();
    return await gitManager!.commit(message);
  });

  ipcMain.handle('git-discard', async (_, files: string[]) => {
    if (!gitManager) initGitManager();
    return await gitManager!.discard(files);
  });

  ipcMain.handle('git-push', async () => {
    console.log('[Main] git-push IPC called');
    if (!gitManager) initGitManager();
    try {
      const result = await gitManager!.push();
      console.log('[Main] git-push completed successfully');
      return result;
    } catch (error: any) {
      console.error('[Main] git-push failed:', error);
      throw error;
    }
  });

  ipcMain.handle('git-pull', async () => {
    if (!gitManager) initGitManager();
    return await gitManager!.pull();
  });

  ipcMain.handle('git-sync', async () => {
    console.log('[Main] git-sync IPC called');
    if (!gitManager) initGitManager();
    try {
      // GitManagerV2 has a sync method, old GitManager doesn't
      if (USE_NEW_GIT_MANAGER && gitManager instanceof GitManagerV2) {
        const result = await gitManager.sync();
        console.log('[Main] git-sync completed successfully');
        return result;
      } else {
        // Fallback for old GitManager - do pull then push
        await gitManager!.pull();
        await gitManager!.push();
        console.log('[Main] git-sync (pull+push) completed successfully');
        return;
      }
    } catch (error: any) {
      console.error('[Main] git-sync failed:', error);
      throw error;
    }
  });

  ipcMain.handle('git-fetch', async () => {
    if (!gitManager) initGitManager();
    return await gitManager!.fetch();
  });

  ipcMain.handle('git-switch-branch', async (_, branchName: string) => {
    if (!gitManager) initGitManager();
    return await gitManager!.switchBranch(branchName);
  });

  ipcMain.handle('git-create-branch', async (_, branchName: string) => {
    if (!gitManager) initGitManager();
    return await gitManager!.createBranch(branchName);
  });

  ipcMain.handle('git-file-status', async (_, filePath: string) => {
    if (!gitManager) initGitManager();
    const status = await gitManager!.getStatus();
    const file = status.files.find(f => f.path === filePath);
    if (file) {
      if (file.index !== ' ' && file.index !== '?') return 'staged';
      if (file.working === 'M') return 'modified';
      if (file.working === 'D') return 'deleted';
      if (file.working === '?') return 'untracked';
      if (file.working === 'A') return 'added';
    }
    return null;
  });
  
  // Initialize Git repository
  ipcMain.handle('git-init', async (_, repoPath: string) => {
    const git = new GitManager(repoPath);
    await git.initRepo();
    return { success: true };
  });
  
  // Get files changed in a commit
  ipcMain.handle('git-commit-files', async (_, hash: string) => {
    if (!gitManager) initGitManager();
    return await gitManager!.getCommitFiles(hash);
  });
  
  // Get diff for a specific file in a commit
  ipcMain.handle('git-file-diff', async (_, commitHash: string, filePath: string) => {
    if (!gitManager) initGitManager();
    return await gitManager!.getFileDiff(commitHash, filePath);
  });
  
  // Update Git manager when folder changes
  ipcMain.handle('git-set-folder', async (_, folderPath: string) => {
    console.log('[Git] Setting folder to:', folderPath);
    if (USE_NEW_GIT_MANAGER) {
      gitManager = new GitManagerV2(folderPath);
    } else {
      gitManager = new GitManager(folderPath);
    }
    return { success: true };
  });
};

const registerDialogHandlers = () => {
  // Dialog IPC handlers
  ipcMain.handle('show-open-dialog', async (_, options: any) => {
    const result = await dialog.showOpenDialog(mainWindow!, options);
    return result;
  });
  
  ipcMain.handle('show-save-dialog', async (_, options: any) => {
    const result = await dialog.showSaveDialog(mainWindow!, options);
    return result;
  });
  
  ipcMain.handle('show-message-box', async (_, options: any) => {
    const result = await dialog.showMessageBox(mainWindow!, options);
    return result;
  });
  
  ipcMain.handle('show-input-dialog', async (_, title: string, defaultValue?: string) => {
    // For now, use a simple prompt-like dialog
    // In a real app, you'd create a custom dialog
    const result = await dialog.showMessageBox(mainWindow!, {
      type: 'question',
      buttons: ['OK', 'Cancel'],
      defaultId: 0,
      title: title,
      message: title,
      detail: defaultValue || ''
    });
    
    if (result.response === 0) {
      // In a real implementation, you'd get the actual input value
      // For now, return a placeholder
      return 'https://github.com/user/repo.git';
    }
    return null;
  });
  
  ipcMain.handle('set-title', (_, title: string) => {
    if (mainWindow) {
      mainWindow.setTitle(title);
    }
  });
};

const registerFileSystemHandlers = () => {
  // File System IPC handlers
  ipcMain.handle('fs-get-tree', async (_, rootPath?: string) => {
    if (!fileSystemManager) initFileSystemManager();
    // Only return files if a root path is explicitly provided
    if (!rootPath) {
      console.log('[Main] fs-get-tree called without root path, returning empty');
      return [];
    }
    console.log('[Main] fs-get-tree called with root:', rootPath);
    const result = await fileSystemManager!.getFileTree(rootPath);
    console.log('[Main] fs-get-tree returning', result?.length || 0, 'items');
    return result;
  });

  ipcMain.handle('fs-get-directory', async (_, dirPath: string) => {
    if (!fileSystemManager) initFileSystemManager();
    console.log('[Main] fs-get-directory called for:', dirPath);
    const result = await fileSystemManager!.getDirectoryContents(dirPath);
    console.log('[Main] fs-get-directory returning', result?.length || 0, 'items for', dirPath);
    return result;
  });

  ipcMain.handle('fs-read-file', async (_, filePath: string) => {
    if (!fileSystemManager) initFileSystemManager();
    return await fileSystemManager!.readFile(filePath);
  });

  ipcMain.handle('fs-write-file', async (_, filePath: string, content: string) => {
    if (!fileSystemManager) initFileSystemManager();
    return await fileSystemManager!.writeFileContent(filePath, content);
  });

  ipcMain.handle('fs-watch-file', async (_, filePath: string) => {
    if (!fileSystemManager) initFileSystemManager();
    fileSystemManager!.watchFile(filePath, () => {
      // Send file change event to renderer
      if (mainWindow) {
        mainWindow.webContents.send('file-changed', filePath);
      }
    });
    return true; // Must return something when using ipcMain.handle
  });

  ipcMain.handle('fs-unwatch-file', async (_, filePath: string) => {
    if (!fileSystemManager) initFileSystemManager();
    fileSystemManager!.unwatchFile(filePath);
    return true; // Must return something when using ipcMain.handle
  });

  ipcMain.handle('fs-search', async (_, rootPath: string, pattern: string) => {
    if (!fileSystemManager) initFileSystemManager();
    return await fileSystemManager!.searchFiles(rootPath, pattern);
  });

  ipcMain.handle('fs-stats', async (_, filePath: string) => {
    if (!fileSystemManager) initFileSystemManager();
    return await fileSystemManager!.getFileStats(filePath);
  });
  
  ipcMain.handle('fs-create-file', async (_, dirPath: string, fileName: string) => {
    try {
      const fs = require('fs').promises;
      const path = require('path');
      const filePath = path.join(dirPath, fileName);
      console.log('[Main] Creating file:', filePath);
      await fs.writeFile(filePath, '', 'utf8');
      console.log('[Main] File created successfully:', filePath);
      return true;
    } catch (error) {
      console.error('[Main] Failed to create file:', error);
      throw error;
    }
  });
  
  ipcMain.handle('fs-create-folder', async (_, dirPath: string, folderName: string) => {
    try {
      const fs = require('fs').promises;
      const path = require('path');
      const folderPath = path.join(dirPath, folderName);
      console.log('[Main] Creating folder:', folderPath);
      await fs.mkdir(folderPath, { recursive: true });
      console.log('[Main] Folder created successfully:', folderPath);
      return true;
    } catch (error) {
      console.error('[Main] Failed to create folder:', error);
      throw error;
    }
  });
  
  ipcMain.handle('fs-move-file', async (_, sourcePath: string, targetPath: string) => {
    try {
      const fs = require('fs').promises;
      console.log('[Main] Moving:', sourcePath, 'to', targetPath);
      await fs.rename(sourcePath, targetPath);
      console.log('[Main] Move successful');
      return true;
    } catch (error) {
      console.error('[Main] Failed to move file:', error);
      throw error;
    }
  });
  
  ipcMain.handle('fs-file-exists', async (_, filePath: string) => {
    try {
      const fs = require('fs').promises;
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  });
};

const createApplicationMenu = () => {
  const template: any[] = [
    {
      label: 'File',
      submenu: [
        {
          label: 'New File',
          accelerator: 'CmdOrCtrl+N',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-new-file');
            }
          }
        },
        {
          label: 'Open File',
          accelerator: 'CmdOrCtrl+O',
          click: async () => {
            const result = await dialog.showOpenDialog(mainWindow!, {
              properties: ['openFile'],
              filters: [
                { name: 'All Files', extensions: ['*'] },
                { name: 'JavaScript', extensions: ['js', 'jsx'] },
                { name: 'TypeScript', extensions: ['ts', 'tsx'] },
                { name: 'HTML', extensions: ['html', 'htm'] },
                { name: 'CSS', extensions: ['css', 'scss', 'less'] },
                { name: 'JSON', extensions: ['json'] },
                { name: 'Markdown', extensions: ['md'] }
              ]
            });
            
            if (!result.canceled && result.filePaths.length > 0) {
              if (mainWindow) {
                mainWindow.webContents.send('menu-open-file', result.filePaths[0]);
              }
            }
          }
        },
        {
          label: 'Open Folder',
          accelerator: 'CmdOrCtrl+K CmdOrCtrl+O',
          click: async () => {
            const result = await dialog.showOpenDialog(mainWindow!, {
              properties: ['openDirectory']
            });
            
            if (!result.canceled && result.filePaths.length > 0) {
              if (mainWindow) {
                mainWindow.webContents.send('menu-open-folder', result.filePaths[0]);
              }
            }
          }
        },
        {
          label: 'Close Folder',
          accelerator: 'CmdOrCtrl+K F',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-close-folder');
            }
          }
        },
        { type: 'separator' },
        {
          label: 'Save',
          accelerator: 'CmdOrCtrl+S',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-save');
            }
          }
        },
        {
          label: 'Save As...',
          accelerator: 'CmdOrCtrl+Shift+S',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-save-as');
            }
          }
        },
        { type: 'separator' },
        {
          label: 'Close Tab',
          accelerator: 'CmdOrCtrl+W',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-close-tab');
            }
          }
        },
        { type: 'separator' },
        {
          label: 'Quit',
          accelerator: process.platform === 'darwin' ? 'Cmd+Q' : 'Ctrl+Q',
          click: () => {
            app.quit();
          }
        }
      ]
    },
    {
      label: 'Edit',
      submenu: [
        { label: 'Undo', accelerator: 'CmdOrCtrl+Z', role: 'undo' },
        { label: 'Redo', accelerator: 'CmdOrCtrl+Y', role: 'redo' },
        { type: 'separator' },
        { label: 'Cut', accelerator: 'CmdOrCtrl+X', role: 'cut' },
        { label: 'Copy', accelerator: 'CmdOrCtrl+C', role: 'copy' },
        { label: 'Paste', accelerator: 'CmdOrCtrl+V', role: 'paste' },
        { type: 'separator' },
        { label: 'Select All', accelerator: 'CmdOrCtrl+A', role: 'selectAll' },
        { type: 'separator' },
        {
          label: 'Find',
          accelerator: 'CmdOrCtrl+F',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-find');
            }
          }
        },
        {
          label: 'Replace',
          accelerator: 'CmdOrCtrl+H',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-replace');
            }
          }
        }
      ]
    },
    {
      label: 'View',
      submenu: [
        {
          label: 'Toggle File Explorer',
          accelerator: 'CmdOrCtrl+B',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-toggle-explorer');
            }
          }
        },
        {
          label: 'Toggle Source Control',
          accelerator: 'CmdOrCtrl+Shift+G',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-toggle-git');
            }
          }
        },
        {
          label: 'Toggle Terminal',
          accelerator: 'CmdOrCtrl+`',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-toggle-terminal');
            }
          }
        },
        { type: 'separator' },
        { label: 'Reload', accelerator: 'CmdOrCtrl+R', role: 'reload' },
        { label: 'Force Reload', accelerator: 'CmdOrCtrl+Shift+R', role: 'forceReload' },
        { label: 'Toggle Developer Tools', accelerator: 'F12', role: 'toggleDevTools' },
        { type: 'separator' },
        { label: 'Actual Size', accelerator: 'CmdOrCtrl+0', role: 'resetZoom' },
        { label: 'Zoom In', accelerator: 'CmdOrCtrl+Plus', role: 'zoomIn' },
        { label: 'Zoom Out', accelerator: 'CmdOrCtrl+-', role: 'zoomOut' },
        { type: 'separator' },
        { label: 'Toggle Fullscreen', accelerator: 'F11', role: 'togglefullscreen' }
      ]
    },
    {
      label: 'Go',
      submenu: [
        {
          label: 'Go to File...',
          accelerator: 'CmdOrCtrl+P',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-go-to-file');
            }
          }
        },
        {
          label: 'Go to Line...',
          accelerator: 'CmdOrCtrl+G',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-go-to-line');
            }
          }
        }
      ]
    },
    {
      label: 'Window',
      submenu: [
        { label: 'Minimize', accelerator: 'CmdOrCtrl+M', role: 'minimize' },
        { label: 'Close', accelerator: 'CmdOrCtrl+W', role: 'close' }
      ]
    },
    {
      label: 'Help',
      submenu: [
        {
          label: 'About',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-about');
            }
          }
        }
      ]
    }
  ];

  // macOS specific menu adjustments
  if (process.platform === 'darwin') {
    template.unshift({
      label: app.getName(),
      submenu: [
        { label: 'About ' + app.getName(), role: 'about' },
        { type: 'separator' },
        { label: 'Services', role: 'services', submenu: [] },
        { type: 'separator' },
        { label: 'Hide ' + app.getName(), accelerator: 'Command+H', role: 'hide' },
        { label: 'Hide Others', accelerator: 'Command+Shift+H', role: 'hideothers' },
        { label: 'Show All', role: 'unhide' },
        { type: 'separator' },
        { label: 'Quit', accelerator: 'Command+Q', click: () => app.quit() }
      ]
    });
  }

  const menu = Menu.buildFromTemplate(template);
  Menu.setApplicationMenu(menu);
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  initDatabase();
  // Don't initialize Git manager on startup - wait until a folder is opened
  // initGitManager(); 
  createWindow();
  
  // Register dialog handlers (Git and FileSystem handlers are already registered in createWindow)
  registerDialogHandlers();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// Set up IPC handlers for backend communication
ipcMain.handle('backend-health', async () => {
  try {
    const response = await fetch('http://localhost:8765/health');
    return await response.json();
  } catch (error) {
    throw error;
  }
});

ipcMain.handle('backend-test', async () => {
  try {
    const response = await fetch('http://localhost:8765/test', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify('Hello from Electron via IPC')
    });
    return await response.json();
  } catch (error) {
    throw error;
  }
});

ipcMain.handle('backend-consensus', async (_, query: string) => {
  try {
    const response = await fetch('http://localhost:8765/api/consensus', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query })
    });
    return await response.json();
  } catch (error) {
    throw error;
  }
});

ipcMain.handle('backend-consensus-quick', async (_, data: {query: string, profile?: string}) => {
  try {
    const response = await fetch('http://127.0.0.1:8765/api/consensus/quick', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    return await response.json();
  } catch (error) {
    console.error('Quick consensus error:', error);
    throw error;
  }
});

// WebSocket proxy - main process handles WebSocket connection
const WebSocket = require('ws');
let wsConnection: any = null;
let wsCallbacks: Map<string, Function> = new Map();

ipcMain.handle('websocket-connect', async (event, url: string) => {
  return new Promise((resolve, reject) => {
    try {
      if (wsConnection) {
        wsConnection.close();
      }
      
      wsConnection = new WebSocket(url);
      
      wsConnection.on('open', () => {
        console.log('WebSocket connected in main process');
        resolve({ connected: true });
      });
      
      wsConnection.on('message', (data: any) => {
        // Forward message to renderer
        event.sender.send('websocket-message', data.toString());
      });
      
      wsConnection.on('error', (error: any) => {
        console.error('WebSocket error in main:', error);
        event.sender.send('websocket-error', error.message);
        reject(error);
      });
      
      wsConnection.on('close', () => {
        console.log('WebSocket closed in main process');
        event.sender.send('websocket-closed');
        wsConnection = null;
      });
      
    } catch (error) {
      reject(error);
    }
  });
});

ipcMain.handle('websocket-send', async (_, message: string) => {
  // Check if WebSocket is open
  if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
    wsConnection.send(message);
    return { sent: true };
  }
  
  // If not connected, try to reconnect once
  console.log('WebSocket not ready, attempting reconnection...');
  try {
    await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject('Connection timeout'), 3000);
      
      if (!wsConnection || wsConnection.readyState === WebSocket.CLOSED) {
        // Reconnect to WebSocket
        wsConnection = new WebSocket('ws://127.0.0.1:8765/ws');
        
        wsConnection.once('open', () => {
          clearTimeout(timeout);
          console.log('WebSocket reconnected successfully');
          resolve(true);
        });
        
        wsConnection.once('error', (err: any) => {
          clearTimeout(timeout);
          reject(err);
        });
        
        // Re-attach message handler for all windows
        wsConnection.on('message', (data: any) => {
          // Send to all windows
          BrowserWindow.getAllWindows().forEach(window => {
            window.webContents.send('websocket-message', data.toString());
          });
        });
      } else if (wsConnection.readyState === WebSocket.CONNECTING) {
        // Wait for existing connection
        wsConnection.once('open', () => {
          clearTimeout(timeout);
          resolve(true);
        });
      } else {
        reject('Unknown WebSocket state');
      }
    });
    
    // Now send the message
    wsConnection.send(message);
    return { sent: true };
  } catch (error) {
    console.error('Failed to reconnect WebSocket:', error);
    throw new Error('WebSocket not connected and reconnection failed');
  }
});

ipcMain.handle('websocket-close', async () => {
  if (wsConnection) {
    wsConnection.close();
    wsConnection = null;
  }
  return { closed: true };
});

// Settings API handlers
ipcMain.handle('settings-load', async () => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    const settings: any = {};
    
    // Load API keys from configurations table (matching Rust implementation)
    db.get('SELECT value FROM configurations WHERE key = ?', ['openrouter_api_key'], (err, row: any) => {
      if (row) settings.openrouterKey = row.value;
      
      db.get('SELECT value FROM configurations WHERE key = ?', ['hive_license_key'], (err2, row2: any) => {
        if (row2) settings.hiveKey = row2.value;
        
        // Load active profile from consensus_settings table (matching Rust implementation)
        db.get('SELECT value FROM consensus_settings WHERE key = ?', ['active_profile_id'], (err3, row3: any) => {
          if (row3) {
            settings.activeProfileId = row3.value;
            // Also get the profile name for better matching
            db.get('SELECT profile_name FROM consensus_profiles WHERE id = ?', [row3.value], (errName, rowName: any) => {
              if (rowName) settings.activeProfileName = rowName.profile_name;
            });
          }
          
          // Load license tier and usage information
          db.get('SELECT value FROM configurations WHERE key = ?', ['hive_tier'], (errTier, rowTier: any) => {
            if (rowTier) settings.hiveTier = rowTier.value;
            
            db.get('SELECT value FROM configurations WHERE key = ?', ['hive_daily_limit'], (errLimit, rowLimit: any) => {
              if (rowLimit) settings.hiveDailyLimit = parseInt(rowLimit.value);
              
              db.get('SELECT value FROM configurations WHERE key = ?', ['hive_remaining'], (errRemaining, rowRemaining: any) => {
                if (rowRemaining) settings.hiveRemaining = parseInt(rowRemaining.value);
                
                // Load other settings
                db.get('SELECT value FROM configurations WHERE key = ?', ['auto_save'], (err4, row4: any) => {
                  if (row4) settings.autoSave = row4.value === 'true';
                  
                  db.get('SELECT value FROM configurations WHERE key = ?', ['show_costs'], (err5, row5: any) => {
                    if (row5) settings.showCosts = row5.value === 'true';
                    
                    db.get('SELECT value FROM configurations WHERE key = ?', ['max_daily_conversations'], (err6, row6: any) => {
                      if (row6) settings.maxDailyConversations = row6.value;
                      resolve(settings);
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
});

ipcMain.handle('settings-test-keys', async (_, { openrouterKey, hiveKey }) => {
  const result: any = { openrouterValid: false, hiveValid: false, licenseInfo: null };
  
  // Test OpenRouter key
  if (openrouterKey && openrouterKey.startsWith('sk-or-')) {
    try {
      const response = await fetch('https://openrouter.ai/api/v1/models', {
        headers: {
          'Authorization': `Bearer ${openrouterKey}`,
          'HTTP-Referer': 'https://hivetechs.io',
          'X-Title': 'hive-ai'
        }
      });
      result.openrouterValid = response.status === 200;
    } catch (error) {
      console.error('Failed to test OpenRouter key:', error);
    }
  }
  
  // Test Hive key - real D1 authentication
  if (hiveKey) {
    const upperKey = hiveKey.toUpperCase();
    if (upperKey.startsWith('HIVE-')) {
      const parts = upperKey.split('-');
      // Validate format first (HIVE-XXXX-XXXX-XXXX or longer)
      if (parts.length >= 4 && parts.slice(1).every((segment: string) => 
        segment.length === 4 && /^[A-Z0-9]{4}$/.test(segment)
      )) {
        try {
          // Create device fingerprint (matching Rust implementation)
          const crypto = require('crypto');
          const hostname = os.hostname();
          const username = os.userInfo().username;
          const platform = os.platform();
          const arch = os.arch();
          const release = os.release();
          const cpus = os.cpus().length;
          const memory = Math.floor(os.totalmem() / 1024 / 1024); // MB
          
          const deviceData = {
            platform,
            arch,
            release,
            cpus,
            memory
          };
          
          const deviceString = JSON.stringify(deviceData);
          const fingerprint = crypto.createHash('sha256')
            .update(deviceString)
            .digest('hex')
            .substring(0, 32);
          
          // Make request to Cloudflare D1 gateway
          const response = await fetch('https://gateway.hivetechs.io/v1/session/validate', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${upperKey}`,
              'Content-Type': 'application/json',
              'User-Agent': 'hive-electron/2.0.0'
            },
            body: JSON.stringify({
              client_id: 'hive-tools',
              session_token: upperKey,
              fingerprint: fingerprint,
              nonce: String(Date.now())
            })
          });
          
          if (response.ok) {
            const data = await response.json();
            
            // Log the D1 response to understand what fields are available
            console.log('D1 validation response:', JSON.stringify(data, null, 2));
            
            if (data.valid) {
              // Parse tier information
              const tier = data.tier || data.user?.subscription_tier || 'free';
              const dailyLimit = data.daily_limit || data.limits?.daily || 10;
              const email = data.email || data.user?.email || '';
              const userId = data.user_id || data.user?.id || '';
              
              // Check if D1 returned usage information
              let remaining = undefined;
              let dailyUsed = undefined;
              
              // D1 is the source of truth for usage - only use if provided
              if (data.usage) {
                // D1 returned usage info - this is authoritative
                remaining = data.usage.remaining;
                const limit = data.usage.limit || dailyLimit;
                
                // Calculate used from remaining (D1 tracks this)
                if (remaining !== undefined && limit !== undefined) {
                  // Handle "unlimited" case where remaining might be max value
                  if (remaining === 4294967295 || remaining === 2147483647) {
                    dailyUsed = 0;
                    remaining = 'unlimited';
                  } else {
                    dailyUsed = Math.max(0, limit - remaining);
                  }
                }
              }
              
              // Build license info object
              const licenseInfo: any = {
                valid: true,
                tier: tier.charAt(0).toUpperCase() + tier.slice(1).toLowerCase(),
                dailyLimit: dailyLimit,
                email: email,
                userId: userId,
                features: data.features || ['consensus']
              };
              
              // Only include usage data if D1 provided it
              if (remaining !== undefined) {
                licenseInfo.remaining = remaining;
              }
              if (dailyUsed !== undefined) {
                licenseInfo.dailyUsed = dailyUsed;
              }
              
              result.hiveValid = true;
              result.licenseInfo = licenseInfo;
              
              // Store validated license info in database
              if (db) {
                const timestamp = new Date().toISOString();
                db.run(
                  `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
                   VALUES (?, ?, ?, ?, ?, ?)
                   ON CONFLICT(key) DO UPDATE SET
                   value = excluded.value,
                   updated_at = excluded.updated_at`,
                  ['hive_tier', tier, 0, userId || 'default', timestamp, timestamp]
                );
                
                db.run(
                  `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
                   VALUES (?, ?, ?, ?, ?, ?)
                   ON CONFLICT(key) DO UPDATE SET
                   value = excluded.value,
                   updated_at = excluded.updated_at`,
                  ['hive_daily_limit', String(dailyLimit), 0, userId || 'default', timestamp, timestamp]
                );
                
                // Only store remaining if D1 provided it
                if (remaining !== undefined) {
                  db.run(
                    `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
                     VALUES (?, ?, ?, ?, ?, ?)
                     ON CONFLICT(key) DO UPDATE SET
                     value = excluded.value,
                     updated_at = excluded.updated_at`,
                    ['hive_remaining', String(remaining), 0, userId || 'default', timestamp, timestamp]
                  );
                }
              }
            } else {
              result.hiveValid = false;
              result.licenseInfo = {
                valid: false,
                error: data.error || 'Invalid license key'
              };
            }
          } else {
            // Handle error responses
            const errorText = await response.text();
            console.error('License validation failed:', response.status, errorText);
            
            result.hiveValid = false;
            result.licenseInfo = {
              valid: false,
              error: `Validation failed: ${response.status}`
            };
          }
        } catch (error) {
          console.error('Failed to validate Hive license:', error);
          result.hiveValid = false;
          result.licenseInfo = {
            valid: false,
            error: 'Network error - unable to validate license'
          };
        }
      } else {
        result.hiveValid = false;
        result.licenseInfo = {
          valid: false,
          error: 'Invalid license key format'
        };
      }
    } else {
      result.hiveValid = false;
      result.licenseInfo = {
        valid: false,
        error: 'License key must start with HIVE-'
      };
    }
  }
  
  return result;
});

ipcMain.handle('settings-save-keys', async (_, { openrouterKey, hiveKey }) => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    const timestamp = new Date().toISOString();
    
    // Save OpenRouter key
    if (openrouterKey) {
      db.run(
        'INSERT OR REPLACE INTO configuration (key, value, updated_at) VALUES (?, ?, ?)',
        ['openrouter_api_key', openrouterKey, timestamp],
        (err) => {
          if (err) {
            reject(err);
            return;
          }
          
          // Save Hive key
          if (hiveKey) {
            db.run(
              'INSERT OR REPLACE INTO configuration (key, value, updated_at) VALUES (?, ?, ?)',
              ['hive_license_key', hiveKey, timestamp],
              (err2) => {
                if (err2) {
                  reject(err2);
                } else {
                  resolve(true);
                }
              }
            );
          } else {
            resolve(true);
          }
        }
      );
    } else if (hiveKey) {
      db.run(
        'INSERT OR REPLACE INTO configuration (key, value, updated_at) VALUES (?, ?, ?)',
        ['hive_license_key', hiveKey, timestamp],
        (err) => {
          if (err) {
            reject(err);
          } else {
            resolve(true);
          }
        }
      );
    } else {
      resolve(true);
    }
  });
});

ipcMain.handle('settings-save-profile', async (_, profile) => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    const timestamp = new Date().toISOString();
    
    // Insert or update the profile (no is_default column in actual database)
    db.run(
      `INSERT OR REPLACE INTO consensus_profiles 
       (id, profile_name, generator_model, refiner_model, validator_model, curator_model, updated_at) 
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [profile.id, profile.name, profile.generator, profile.refiner, profile.validator, profile.curator, timestamp],
      (err2) => {
        if (err2) {
          reject(err2);
        } else {
          // Save to consensus_settings table (matching Rust implementation)
          db.run(
            `INSERT INTO consensus_settings (key, value, updated_at) 
             VALUES (?, ?, ?)
             ON CONFLICT(key) DO UPDATE SET
             value = excluded.value,
             updated_at = excluded.updated_at`,
            ['active_profile_id', profile.id, timestamp],
            (err3) => {
              if (err3) {
                reject(err3);
              } else {
                resolve(true);
              }
            }
          );
        }
      }
    );
  });
});

ipcMain.handle('settings-save-all', async (_, settings) => {
  return new Promise(async (resolve, reject) => {
    try {
      const timestamp = new Date().toISOString();
      const userId = 'default';
      
      // Save API keys to configurations table (matching Rust implementation)
      if (settings.openrouterKey || settings.hiveKey) {
        if (settings.openrouterKey) {
          db.run(
            `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
             VALUES (?, ?, ?, ?, ?, ?)
             ON CONFLICT(key) DO UPDATE SET
             value = excluded.value,
             updated_at = excluded.updated_at`,
            ['openrouter_api_key', settings.openrouterKey, 0, userId, timestamp, timestamp]
          );
        }
        if (settings.hiveKey) {
          db.run(
            `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
             VALUES (?, ?, ?, ?, ?, ?)
             ON CONFLICT(key) DO UPDATE SET
             value = excluded.value,
             updated_at = excluded.updated_at`,
            ['hive_license_key', settings.hiveKey, 0, userId, timestamp, timestamp]
          );
        }
      }
      
      // Save profile to consensus_settings (matching Rust implementation)
      if (settings.selectedProfile) {
        // Save to consensus_settings table
        db.run(
          `INSERT INTO consensus_settings (key, value, updated_at) 
           VALUES (?, ?, ?)
           ON CONFLICT(key) DO UPDATE SET
           value = excluded.value,
           updated_at = excluded.updated_at`,
          ['active_profile_id', settings.selectedProfile, timestamp],
          (err) => {
            if (err) console.error('Failed to save active profile:', err);
          }
        );
        
        // Note: No is_default column in actual consensus_profiles table
      }
      
      // Save other settings to configurations table
      if (settings.autoSave !== undefined) {
        db.run(
          `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
           VALUES (?, ?, ?, ?, ?, ?)
           ON CONFLICT(key) DO UPDATE SET
           value = excluded.value,
           updated_at = excluded.updated_at`,
          ['auto_save', settings.autoSave.toString(), 0, userId, timestamp, timestamp]
        );
      }
      if (settings.showCosts !== undefined) {
        db.run(
          `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
           VALUES (?, ?, ?, ?, ?, ?)
           ON CONFLICT(key) DO UPDATE SET
           value = excluded.value,
           updated_at = excluded.updated_at`,
          ['show_costs', settings.showCosts.toString(), 0, userId, timestamp, timestamp]
        );
      }
      if (settings.maxDailyConversations !== undefined) {
        db.run(
          `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
           VALUES (?, ?, ?, ?, ?, ?)
           ON CONFLICT(key) DO UPDATE SET
           value = excluded.value,
           updated_at = excluded.updated_at`,
          ['max_daily_conversations', settings.maxDailyConversations.toString(), 0, userId, timestamp, timestamp]
        );
      }
      
      resolve(true);
    } catch (error) {
      reject(error);
    }
  });
});

ipcMain.handle('settings-load-profiles', async () => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    db.all(
      'SELECT * FROM consensus_profiles ORDER BY profile_name',
      [],
      (err, rows) => {
        if (err) {
          reject(err);
        } else {
          // Map to expected format
          const profiles = rows.map((row: any) => ({
            id: row.id,
            name: row.profile_name,
            generator: row.generator_model,
            refiner: row.refiner_model,
            validator: row.validator_model,
            curator: row.curator_model
          }));
          resolve(profiles);
        }
      }
    );
  });
});

ipcMain.handle('settings-load-models', async () => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    // First check if openrouter_models table exists
    db.get(
      "SELECT name FROM sqlite_master WHERE type='table' AND name='openrouter_models'",
      [],
      (err, row) => {
        if (err || !row) {
          // Table doesn't exist, return empty array
          resolve([]);
          return;
        }

        // Load all active models from database
        db.all(
          `SELECT internal_id, openrouter_id, name, provider_name, description,
                  context_window, pricing_input, pricing_output, is_active
           FROM openrouter_models
           WHERE is_active = 1
           ORDER BY provider_name, name`,
          [],
          (err2, rows) => {
            if (err2) {
              reject(err2);
            } else {
              // Map to format expected by frontend
              const models = rows.map((row: any) => ({
                value: row.openrouter_id,
                label: row.name,
                provider: row.provider_name,
                description: row.description,
                contextWindow: row.context_window,
                pricingInput: row.pricing_input,
                pricingOutput: row.pricing_output,
                internalId: row.internal_id
              }));
              resolve(models);
            }
          }
        );
      }
    );
  });
});

ipcMain.handle('settings-reset', async () => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    // Clear configuration except essential items
    db.run('DELETE FROM configuration WHERE key NOT IN ("openrouter_api_key", "hive_license_key")', (err) => {
      if (err) {
        reject(err);
      } else {
        // Reset profile to default
        // Set balanced-performer as the active profile in consensus_settings
        db.run(
          `INSERT INTO consensus_settings (key, value, updated_at) 
           VALUES (?, ?, ?)
           ON CONFLICT(key) DO UPDATE SET
           value = excluded.value,
           updated_at = excluded.updated_at`,
          ['active_profile_id', 'balanced-performer', new Date().toISOString()],
          () => {
            resolve(true);
          }
        );
      }
    });
  });
});

// Analytics data handler - fetch real consensus metrics from database
// Save conversation to database
ipcMain.handle('save-conversation', async (_, data: {
  conversationId: string;
  question: string;
  answer: string;
  totalCost: number;
  totalTokens: number;
  inputTokens: number;
  outputTokens: number;
  model?: string;
  duration?: number;
}) => {
  return new Promise((resolve) => {
    if (!db) {
      console.error('Database not initialized for saving conversation');
      resolve(false);
      return;
    }
    
    console.log('ðŸ“ Saving conversation to database:', {
      id: data.conversationId,
      cost: data.totalCost,
      tokens: data.totalTokens
    });
    
    const userId = '3034c561-e193-4968-a575-f1b165d31a5b'; // sales@hivetechs.io
    const timestamp = new Date().toISOString();
    
    // Insert into conversations table
    db.run(`
      INSERT INTO conversations (
        id, user_id, title, total_cost, total_tokens_input, total_tokens_output, 
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      data.conversationId,
      userId,
      data.question?.substring(0, 100) || 'Consensus Query',
      data.totalCost,
      data.inputTokens,
      data.outputTokens,
      timestamp,
      timestamp
    ], (err1) => {
      if (err1) {
        console.error('Error saving conversation:', err1);
        resolve(false);
        return;
      }
      
      // Insert into knowledge_conversations
      db.run(`
        INSERT INTO knowledge_conversations (
          conversation_id, question, final_answer, source_of_truth, created_at
        ) VALUES (?, ?, ?, ?, ?)
      `, [
        data.conversationId,
        data.question,
        data.answer,
        data.answer, // Using answer as source of truth for now
        timestamp
      ], (err2) => {
        if (err2) console.error('Error saving to knowledge_conversations:', err2);
      });
      
      // Insert into conversation_usage for tracking
      db.run(`
        INSERT INTO conversation_usage (
          user_id, conversation_id, timestamp
        ) VALUES (?, ?, ?)
      `, [userId, data.conversationId, timestamp], (err3) => {
        if (err3) console.error('Error saving to conversation_usage:', err3);
      });
      
      // Track model usage for each stage using the active profile
      // Get the active profile to know which models were used
      db.get(`
        SELECT cp.generator_model, cp.refiner_model, cp.validator_model, cp.curator_model 
        FROM consensus_settings cs
        JOIN consensus_profiles cp ON cs.value = cp.id
        WHERE cs.key = 'active_profile_id'
      `, [], (errProfile, profile: any) => {
        if (!errProfile && profile) {
          // Insert stage outputs for tracking
          const stages = [
            { name: 'Generator', model: profile.generator_model },
            { name: 'Refiner', model: profile.refiner_model },
            { name: 'Validator', model: profile.validator_model },
            { name: 'Curator', model: profile.curator_model }
          ];
          
          stages.forEach(stage => {
            // Estimate tokens and cost per stage (divide by 4)
            const stageTokens = Math.floor((data.totalTokens || 0) / 4);
            const stageCost = (data.totalCost || 0) / 4;
            
            db.run(`
              INSERT INTO stage_outputs (
                conversation_id, stage_name, model, tokens_used, cost, created_at
              ) VALUES (?, ?, ?, ?, ?, ?)
            `, [data.conversationId, stage.name, stage.model, stageTokens, stageCost, timestamp]);
          });
        }
      });
      
      // Insert into performance_metrics if duration provided
      if (data.duration) {
        db.run(`
          INSERT INTO performance_metrics (
            conversation_id, timestamp, total_duration, total_cost, created_at
          ) VALUES (?, ?, ?, ?, ?)
        `, [data.conversationId, timestamp, data.duration, data.totalCost || 0, timestamp], (err4) => {
          if (err4) console.error('Error saving performance metrics:', err4);
        });
      }
      
      // Insert into cost_analytics
      db.run(`
        INSERT INTO cost_analytics (
          conversation_id, total_cost, cost_per_token, model_costs, optimization_potential, created_at
        ) VALUES (?, ?, ?, ?, ?, ?)
      `, [
        data.conversationId,
        data.totalCost,
        data.totalCost / (data.totalTokens || 1),
        JSON.stringify({ [data.model || 'consensus']: data.totalCost }),
        0,
        timestamp
      ], (err5) => {
        if (err5) console.error('Error saving cost analytics:', err5);
      });
      
      console.log(`âœ… Saved conversation ${data.conversationId} to database`);
      resolve(true);
    });
  });
});

// Get user's daily usage count
ipcMain.handle('get-usage-count', async () => {
  return new Promise((resolve) => {
    if (!db) {
      resolve({ used: 0, limit: 999999, remaining: 999999 });
      return;
    }
    
    const userId = '3034c561-e193-4968-a575-f1b165d31a5b';
    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);
    
    db.get(`
      SELECT COUNT(*) as count 
      FROM conversation_usage 
      WHERE user_id = ? 
      AND date(timestamp, 'localtime') = date('now', 'localtime')
    `, [userId], (err, row: any) => {
      if (err) {
        console.error('Error getting usage count:', err);
        resolve({ used: 0, limit: 999999, remaining: 999999 });
        return;
      }
      
      const used = row?.count || 0;
      const limit = 999999; // Unlimited for this user
      const remaining = limit - used;
      
      console.log(`Usage count for user ${userId}: ${used} / ${limit}`);
      resolve({ used, limit, remaining });
    });
  });
});

ipcMain.handle('get-analytics', async () => {
  return new Promise((resolve) => {
    if (!db) {
      console.error('Database not initialized for analytics');
      resolve(null);
      return;
    }

    const analyticsData: any = {};
    
    // Calculate date ranges
    const now = new Date();
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString();
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString();
    
    // Get user-specific data - using the logged-in user's ID
    // This comes from the D1 validation response stored earlier
    const userId = '3034c561-e193-4968-a575-f1b165d31a5b'; // sales@hivetechs.io user ID
    
    // Get TODAY's queries for this user from conversation_usage table
    // Use UTC dates consistently since timestamps are stored in UTC
    db.get(`
      SELECT COUNT(*) as count 
      FROM conversation_usage 
      WHERE date(timestamp, 'localtime') = date('now', 'localtime') 
      AND user_id = ?
    `, [userId], (err1, row1: any) => {
      if (err1) {
        console.error('Error getting conversation count:', err1);
        resolve(null);
        return;
      }
      
      console.log('Analytics - Today queries for user:', row1?.count);
      analyticsData.todayQueries = row1?.count || 0;
      
      // Get all-time total queries for this user
      db.get(`
        SELECT COUNT(*) as count 
        FROM conversation_usage 
        WHERE user_id = ?
      `, [userId], (errTotal, rowTotal: any) => {
        console.log('Analytics - Total queries for user:', rowTotal?.count);
        analyticsData.totalQueries = rowTotal?.count || 0;
      
        // Get TODAY's cost and token usage - join with conversation_usage for user filtering
        // Convert UTC timestamps to localtime for date comparison
        db.get(`
          SELECT 
            SUM(c.total_cost) as total_cost,
            SUM(c.total_tokens_input) as total_input,
            SUM(c.total_tokens_output) as total_output,
            AVG(pm.total_duration / 1000.0) as avg_time
          FROM conversations c
          INNER JOIN conversation_usage cu ON c.id = cu.conversation_id
          LEFT JOIN performance_metrics pm ON c.id = pm.conversation_id
          WHERE date(cu.timestamp, 'localtime') = date('now', 'localtime')
          AND cu.user_id = ?
        `, [userId], (err2, row2: any) => {
        if (err2) console.error('Error getting today cost data:', err2);
        
          console.log('Analytics - Today cost data:', row2);
          analyticsData.todayCost = row2?.total_cost || 0;
          analyticsData.todayAvgResponseTime = row2?.avg_time || 0;
          analyticsData.todayTokenUsage = {
            total: (row2?.total_input || 0) + (row2?.total_output || 0),
            input: row2?.total_input || 0,
            output: row2?.total_output || 0
          };
          
          // Get all-time totals - join with conversation_usage for user filtering
          db.get(`
            SELECT 
              SUM(c.total_cost) as total_cost,
              SUM(c.total_tokens_input) as total_input,
              SUM(c.total_tokens_output) as total_output,
              AVG(pm.total_duration / 1000.0) as avg_time
            FROM conversations c
            INNER JOIN conversation_usage cu ON c.id = cu.conversation_id
            LEFT JOIN performance_metrics pm ON c.id = pm.conversation_id
            WHERE cu.user_id = ?
          `, [userId], (errAllTime, rowAllTime: any) => {
            if (errAllTime) console.error('Error getting all-time cost data:', errAllTime);
            console.log('Analytics - All-time cost data:', rowAllTime);
            analyticsData.totalCost = rowAllTime?.total_cost || 0;
            analyticsData.avgResponseTime = rowAllTime?.avg_time || 0;
            analyticsData.tokenUsage = {
              total: (rowAllTime?.total_input || 0) + (rowAllTime?.total_output || 0),
              input: rowAllTime?.total_input || 0,
              output: rowAllTime?.total_output || 0
            };
        
        // Get recent activity - join with conversation_usage for user filtering
        db.all(`
          SELECT 
            c.id as conversation_id,
            kc.question,
            c.total_cost as cost,
            c.total_tokens_input,
            c.total_tokens_output,
            pm.total_duration as duration,
            cu.timestamp
          FROM conversation_usage cu
          INNER JOIN conversations c ON c.id = cu.conversation_id
          LEFT JOIN knowledge_conversations kc ON c.id = kc.conversation_id
          LEFT JOIN performance_metrics pm ON c.id = pm.conversation_id
          WHERE cu.user_id = ?
          ORDER BY cu.timestamp DESC 
          LIMIT 10
        `, [userId], (err3, rows3: any[]) => {
          if (err3) console.error('Error getting recent activity:', err3);
          
          console.log('Recent activity rows:', rows3?.slice(0, 2)); // Log first 2 rows
          
          analyticsData.recentActivity = (rows3 || []).map((row: any) => ({
            timestamp: row.timestamp,
            question: row.question || 'Query', // Fixed fallback text
            model: 'consensus-pipeline',
            cost: row.cost || 0,
            duration: (row.duration || 0) / 1000, // Convert to seconds
            status: 'completed',
            tokens: (row.total_tokens_input || 0) + (row.total_tokens_output || 0),
            conversationId: row.conversation_id
          }));
          
          // Get model usage from stage_outputs table (tracks all 4 models per conversation)
          db.all(`
            SELECT 
              so.model,
              COUNT(*) as count,
              SUM(so.cost) as totalCost
            FROM stage_outputs so
            INNER JOIN conversation_usage cu ON so.conversation_id = cu.conversation_id
            WHERE cu.user_id = ?
            GROUP BY so.model
            ORDER BY totalCost DESC
          `, [userId], (err4, rows4: any[]) => {
            if (err4) {
              console.error('Error getting model usage from stage_outputs:', err4);
              // Fallback: Get models from consensus_profiles if stage_outputs is empty
              db.all(`
                SELECT 
                  cp.generator_model as model,
                  COUNT(c.id) as count,
                  SUM(c.total_cost * 0.25) as totalCost
                FROM conversations c
                INNER JOIN conversation_usage cu ON c.id = cu.conversation_id
                LEFT JOIN consensus_profiles cp ON c.profile_id = cp.id
                WHERE cu.user_id = ? AND cp.generator_model IS NOT NULL
                GROUP BY cp.generator_model
                UNION ALL
                SELECT 
                  cp.refiner_model as model,
                  COUNT(c.id) as count,
                  SUM(c.total_cost * 0.25) as totalCost
                FROM conversations c
                INNER JOIN conversation_usage cu ON c.id = cu.conversation_id
                LEFT JOIN consensus_profiles cp ON c.profile_id = cp.id
                WHERE cu.user_id = ? AND cp.refiner_model IS NOT NULL
                GROUP BY cp.refiner_model
                UNION ALL
                SELECT 
                  cp.validator_model as model,
                  COUNT(c.id) as count,
                  SUM(c.total_cost * 0.25) as totalCost
                FROM conversations c
                INNER JOIN conversation_usage cu ON c.id = cu.conversation_id
                LEFT JOIN consensus_profiles cp ON c.profile_id = cp.id
                WHERE cu.user_id = ? AND cp.validator_model IS NOT NULL
                GROUP BY cp.validator_model
                UNION ALL
                SELECT 
                  cp.curator_model as model,
                  COUNT(c.id) as count,
                  SUM(c.total_cost * 0.25) as totalCost
                FROM conversations c
                INNER JOIN conversation_usage cu ON c.id = cu.conversation_id
                LEFT JOIN consensus_profiles cp ON c.profile_id = cp.id
                WHERE cu.user_id = ? AND cp.curator_model IS NOT NULL
                GROUP BY cp.curator_model
              `, [userId, userId, userId, userId], (err5, rows5: any[]) => {
                const modelUsage: { [model: string]: number } = {};
                const modelCosts: { [model: string]: number } = {};
                
                // Aggregate the model data
                (rows5 || []).forEach((row: any) => {
                  const modelName = row.model?.split('/').pop() || row.model; // Simplify model names
                  if (!modelUsage[modelName]) {
                    modelUsage[modelName] = 0;
                    modelCosts[modelName] = 0;
                  }
                  modelUsage[modelName] += row.count || 0;
                  modelCosts[modelName] += row.totalCost || 0;
                });
                
                analyticsData.modelUsage = modelUsage;
                analyticsData.costByModel = modelCosts;
                continueProcessing();
              });
              return;
            }
            
            const modelUsage: { [model: string]: number } = {};
            const modelCosts: { [model: string]: number } = {};
            
            // Process the results from stage_outputs
            (rows4 || []).forEach((row: any) => {
              const modelName = row.model?.split('/').pop() || row.model; // Simplify model names
              if (row.count > 0) {
                modelUsage[modelName] = row.count;
                modelCosts[modelName] = row.totalCost || 0;
              }
            });
            
            analyticsData.modelUsage = modelUsage;
            analyticsData.costByModel = modelCosts;
            continueProcessing();
          });
          
          function continueProcessing() {
            // Calculate hourly stats for last 24 hours
            const hourlyStats: any[] = [];
            const now = new Date();
            
            const processHour = (i: number) => {
              if (i < 0) {
                // All hours processed
                analyticsData.hourlyStats = hourlyStats;
                analyticsData.successRate = analyticsData.totalQueries > 0 ? 100 : 0;
                
                // Add alerts
                analyticsData.alerts = [{
                  type: 'info',
                  message: `Database contains ${analyticsData.totalQueries} consensus queries`,
                  timestamp: new Date().toISOString()
                }];
                
                // Resolve with complete data
                console.log('Analytics - Complete data:', JSON.stringify(analyticsData, null, 2));
                resolve(analyticsData);
                return;
              }
              
              const hourStart = new Date(now.getTime() - (i + 1) * 60 * 60 * 1000);
              const hourEnd = new Date(now.getTime() - i * 60 * 60 * 1000);
              
              db.get(`
                SELECT 
                  COUNT(DISTINCT cu.conversation_id) as queries,
                  SUM(c.total_cost) as cost,
                  AVG(pm.total_duration / 1000.0) as avg_time
                FROM conversation_usage cu
                LEFT JOIN conversations c ON c.id = cu.conversation_id
                LEFT JOIN performance_metrics pm ON c.id = pm.conversation_id
                WHERE cu.timestamp >= ? AND cu.timestamp < ?
                AND cu.user_id = ?
              `, [hourStart.toISOString(), hourEnd.toISOString(), userId], (err5, row5: any) => {
                if (err5) {
                  console.error('Error getting hourly stats:', err5);
                  // Continue with default values even if error
                  hourlyStats.push({
                    hour: hourStart.getHours().toString().padStart(2, '0') + ':00',
                    queries: 0,
                    cost: 0,
                    avgTime: 0
                  });
                  processHour(i - 1);
                  return;
                }
                
                hourlyStats.push({
                  hour: hourStart.getHours().toString().padStart(2, '0') + ':00',
                  queries: row5?.queries || 0,
                  cost: row5?.cost || 0,
                  avgTime: row5?.avg_time || 0
                });
                
                // Process next hour
                processHour(i - 1);
              });
            };
            
            // Start processing hours from 23 to 0
            processHour(23);
          }
        });
      });
      });
    });
  });
});

// Store reference to main window
app.on('browser-window-created', (_, window) => {
  if (!mainWindow) {
    mainWindow = window;
  }
});
});
