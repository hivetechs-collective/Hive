import { app, BrowserWindow, ipcMain } from 'electron';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';
import { Database } from 'sqlite3';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

let db: Database | null = null;

// Initialize SQLite database connection - use the existing hive-ai.db
const initDatabase = () => {
  // Use the actual Hive database location
  const dbPath = path.join(os.homedir(), '.hive', 'hive-ai.db');
  
  // Create .hive directory if it doesn't exist
  const hiveDir = path.join(os.homedir(), '.hive');
  if (!fs.existsSync(hiveDir)) {
    fs.mkdirSync(hiveDir, { recursive: true });
  }
  
  db = new Database(dbPath);
  
  // The database already exists with proper schema
  // Just ensure the configurations table exists (matching Rust implementation)
  db.run(`CREATE TABLE IF NOT EXISTS configurations (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    encrypted BOOLEAN DEFAULT 0,
    user_id TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
  )`);
  
  // Ensure users table exists with default user
  db.run(`CREATE TABLE IF NOT EXISTS users (
    id TEXT PRIMARY KEY,
    email TEXT,
    tier TEXT
  )`);
  
  // Insert default user if not exists
  db.run(`INSERT OR IGNORE INTO users (id, email, tier) VALUES ('default', 'default@hive.ai', 'FREE')`);
  
  // Create consensus_settings table for active profile
  db.run(`CREATE TABLE IF NOT EXISTS consensus_settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
  )`);
  
  // Keep consensus profiles table matching actual database schema
  db.run(`CREATE TABLE IF NOT EXISTS consensus_profiles (
    id TEXT PRIMARY KEY,
    profile_name TEXT NOT NULL,
    generator_model TEXT NOT NULL,
    refiner_model TEXT NOT NULL,
    validator_model TEXT NOT NULL,
    curator_model TEXT NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
  )`);
};

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
      webSecurity: false, // Allow HTTP requests to localhost for development
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  initDatabase();
  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// Set up IPC handlers for backend communication
ipcMain.handle('backend-health', async () => {
  try {
    const response = await fetch('http://localhost:8765/health');
    return await response.json();
  } catch (error) {
    throw error;
  }
});

ipcMain.handle('backend-test', async () => {
  try {
    const response = await fetch('http://localhost:8765/test', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify('Hello from Electron via IPC')
    });
    return await response.json();
  } catch (error) {
    throw error;
  }
});

ipcMain.handle('backend-consensus', async (_, query: string) => {
  try {
    const response = await fetch('http://localhost:8765/api/consensus', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query })
    });
    return await response.json();
  } catch (error) {
    throw error;
  }
});

// Settings API handlers
ipcMain.handle('settings-load', async () => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    const settings: any = {};
    
    // Load API keys from configurations table (matching Rust implementation)
    db.get('SELECT value FROM configurations WHERE key = ?', ['openrouter_api_key'], (err, row: any) => {
      if (row) settings.openrouterKey = row.value;
      
      db.get('SELECT value FROM configurations WHERE key = ?', ['hive_license_key'], (err2, row2: any) => {
        if (row2) settings.hiveKey = row2.value;
        
        // Load active profile from consensus_settings table (matching Rust implementation)
        db.get('SELECT value FROM consensus_settings WHERE key = ?', ['active_profile_id'], (err3, row3: any) => {
          if (row3) {
            settings.activeProfileId = row3.value;
            // Also get the profile name for better matching
            db.get('SELECT profile_name FROM consensus_profiles WHERE id = ?', [row3.value], (errName, rowName: any) => {
              if (rowName) settings.activeProfileName = rowName.profile_name;
            });
          }
          
          // Load other settings
          db.get('SELECT value FROM configurations WHERE key = ?', ['auto_save'], (err4, row4: any) => {
            if (row4) settings.autoSave = row4.value === 'true';
            
            db.get('SELECT value FROM configurations WHERE key = ?', ['show_costs'], (err5, row5: any) => {
              if (row5) settings.showCosts = row5.value === 'true';
              
              db.get('SELECT value FROM configurations WHERE key = ?', ['max_daily_conversations'], (err6, row6: any) => {
                if (row6) settings.maxDailyConversations = row6.value;
                resolve(settings);
              });
            });
          });
        });
      });
    });
  });
});

ipcMain.handle('settings-test-keys', async (_, { openrouterKey, hiveKey }) => {
  const result: any = { openrouterValid: false, hiveValid: false, licenseInfo: null };
  
  // Test OpenRouter key
  if (openrouterKey && openrouterKey.startsWith('sk-or-')) {
    try {
      const response = await fetch('https://openrouter.ai/api/v1/models', {
        headers: {
          'Authorization': `Bearer ${openrouterKey}`,
          'HTTP-Referer': 'https://hivetechs.io',
          'X-Title': 'hive-ai'
        }
      });
      result.openrouterValid = response.status === 200;
    } catch (error) {
      console.error('Failed to test OpenRouter key:', error);
    }
  }
  
  // Test Hive key (would normally check against Cloudflare D1)
  if (hiveKey && hiveKey.startsWith('hive-')) {
    // For now, just validate format
    result.hiveValid = true;
    result.licenseInfo = {
      valid: true,
      tier: 'premium',
      dailyLimit: 1000
    };
  }
  
  return result;
});

ipcMain.handle('settings-save-keys', async (_, { openrouterKey, hiveKey }) => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    const timestamp = new Date().toISOString();
    
    // Save OpenRouter key
    if (openrouterKey) {
      db.run(
        'INSERT OR REPLACE INTO configuration (key, value, updated_at) VALUES (?, ?, ?)',
        ['openrouter_api_key', openrouterKey, timestamp],
        (err) => {
          if (err) {
            reject(err);
            return;
          }
          
          // Save Hive key
          if (hiveKey) {
            db.run(
              'INSERT OR REPLACE INTO configuration (key, value, updated_at) VALUES (?, ?, ?)',
              ['hive_license_key', hiveKey, timestamp],
              (err2) => {
                if (err2) {
                  reject(err2);
                } else {
                  resolve(true);
                }
              }
            );
          } else {
            resolve(true);
          }
        }
      );
    } else if (hiveKey) {
      db.run(
        'INSERT OR REPLACE INTO configuration (key, value, updated_at) VALUES (?, ?, ?)',
        ['hive_license_key', hiveKey, timestamp],
        (err) => {
          if (err) {
            reject(err);
          } else {
            resolve(true);
          }
        }
      );
    } else {
      resolve(true);
    }
  });
});

ipcMain.handle('settings-save-profile', async (_, profile) => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    const timestamp = new Date().toISOString();
    
    // Insert or update the profile (no is_default column in actual database)
    db.run(
      `INSERT OR REPLACE INTO consensus_profiles 
       (id, profile_name, generator_model, refiner_model, validator_model, curator_model, updated_at) 
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [profile.id, profile.name, profile.generator, profile.refiner, profile.validator, profile.curator, timestamp],
      (err2) => {
        if (err2) {
          reject(err2);
        } else {
          // Save to consensus_settings table (matching Rust implementation)
          db.run(
            `INSERT INTO consensus_settings (key, value, updated_at) 
             VALUES (?, ?, ?)
             ON CONFLICT(key) DO UPDATE SET
             value = excluded.value,
             updated_at = excluded.updated_at`,
            ['active_profile_id', profile.id, timestamp],
            (err3) => {
              if (err3) {
                reject(err3);
              } else {
                resolve(true);
              }
            }
          );
        }
      }
    );
  });
});

ipcMain.handle('settings-save-all', async (_, settings) => {
  return new Promise(async (resolve, reject) => {
    try {
      const timestamp = new Date().toISOString();
      const userId = 'default';
      
      // Save API keys to configurations table (matching Rust implementation)
      if (settings.openrouterKey || settings.hiveKey) {
        if (settings.openrouterKey) {
          db.run(
            `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
             VALUES (?, ?, ?, ?, ?, ?)
             ON CONFLICT(key) DO UPDATE SET
             value = excluded.value,
             updated_at = excluded.updated_at`,
            ['openrouter_api_key', settings.openrouterKey, 0, userId, timestamp, timestamp]
          );
        }
        if (settings.hiveKey) {
          db.run(
            `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
             VALUES (?, ?, ?, ?, ?, ?)
             ON CONFLICT(key) DO UPDATE SET
             value = excluded.value,
             updated_at = excluded.updated_at`,
            ['hive_license_key', settings.hiveKey, 0, userId, timestamp, timestamp]
          );
        }
      }
      
      // Save profile to consensus_settings (matching Rust implementation)
      if (settings.selectedProfile) {
        // Save to consensus_settings table
        db.run(
          `INSERT INTO consensus_settings (key, value, updated_at) 
           VALUES (?, ?, ?)
           ON CONFLICT(key) DO UPDATE SET
           value = excluded.value,
           updated_at = excluded.updated_at`,
          ['active_profile_id', settings.selectedProfile, timestamp],
          (err) => {
            if (err) console.error('Failed to save active profile:', err);
          }
        );
        
        // Note: No is_default column in actual consensus_profiles table
      }
      
      // Save other settings to configurations table
      if (settings.autoSave !== undefined) {
        db.run(
          `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
           VALUES (?, ?, ?, ?, ?, ?)
           ON CONFLICT(key) DO UPDATE SET
           value = excluded.value,
           updated_at = excluded.updated_at`,
          ['auto_save', settings.autoSave.toString(), 0, userId, timestamp, timestamp]
        );
      }
      if (settings.showCosts !== undefined) {
        db.run(
          `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
           VALUES (?, ?, ?, ?, ?, ?)
           ON CONFLICT(key) DO UPDATE SET
           value = excluded.value,
           updated_at = excluded.updated_at`,
          ['show_costs', settings.showCosts.toString(), 0, userId, timestamp, timestamp]
        );
      }
      if (settings.maxDailyConversations !== undefined) {
        db.run(
          `INSERT INTO configurations (key, value, encrypted, user_id, created_at, updated_at) 
           VALUES (?, ?, ?, ?, ?, ?)
           ON CONFLICT(key) DO UPDATE SET
           value = excluded.value,
           updated_at = excluded.updated_at`,
          ['max_daily_conversations', settings.maxDailyConversations.toString(), 0, userId, timestamp, timestamp]
        );
      }
      
      resolve(true);
    } catch (error) {
      reject(error);
    }
  });
});

ipcMain.handle('settings-load-profiles', async () => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    db.all(
      'SELECT * FROM consensus_profiles ORDER BY profile_name',
      [],
      (err, rows) => {
        if (err) {
          reject(err);
        } else {
          // Map to expected format
          const profiles = rows.map((row: any) => ({
            id: row.id,
            name: row.profile_name,
            generator: row.generator_model,
            refiner: row.refiner_model,
            validator: row.validator_model,
            curator: row.curator_model
          }));
          resolve(profiles);
        }
      }
    );
  });
});

ipcMain.handle('settings-load-models', async () => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    // First check if openrouter_models table exists
    db.get(
      "SELECT name FROM sqlite_master WHERE type='table' AND name='openrouter_models'",
      [],
      (err, row) => {
        if (err || !row) {
          // Table doesn't exist, return empty array
          resolve([]);
          return;
        }

        // Load all active models from database
        db.all(
          `SELECT internal_id, openrouter_id, name, provider_name, description,
                  context_window, pricing_input, pricing_output, is_active
           FROM openrouter_models
           WHERE is_active = 1
           ORDER BY provider_name, name`,
          [],
          (err2, rows) => {
            if (err2) {
              reject(err2);
            } else {
              // Map to format expected by frontend
              const models = rows.map((row: any) => ({
                value: row.openrouter_id,
                label: row.name,
                provider: row.provider_name,
                description: row.description,
                contextWindow: row.context_window,
                pricingInput: row.pricing_input,
                pricingOutput: row.pricing_output,
                internalId: row.internal_id
              }));
              resolve(models);
            }
          }
        );
      }
    );
  });
});

ipcMain.handle('settings-reset', async () => {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject('Database not initialized');
      return;
    }

    // Clear configuration except essential items
    db.run('DELETE FROM configuration WHERE key NOT IN ("openrouter_api_key", "hive_license_key")', (err) => {
      if (err) {
        reject(err);
      } else {
        // Reset profile to default
        // Set balanced-performer as the active profile in consensus_settings
        db.run(
          `INSERT INTO consensus_settings (key, value, updated_at) 
           VALUES (?, ?, ?)
           ON CONFLICT(key) DO UPDATE SET
           value = excluded.value,
           updated_at = excluded.updated_at`,
          ['active_profile_id', 'balanced-performer', new Date().toISOString()],
          () => {
            resolve(true);
          }
        );
      }
    });
  });
});
