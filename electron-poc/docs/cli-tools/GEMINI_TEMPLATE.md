# Gemini CLI Integration - Complete Working Template

## Overview
This document captures the COMPLETE working implementation of Gemini CLI integration, serving as the definitive template for all future AI CLI tool integrations.

## Critical Lesson Learned
**The Install button was never tested with Claude Code** because it was pre-installed. Gemini CLI exposed the webpack bundling issue that prevented runtime `require()` from working.

## Complete Implementation Checklist

### Step 0: BECOME AN EXPERT (MANDATORY FIRST STEP)
- [ ] Read the tool's documentation file in `docs/cli-tools/[tool-name].md`
- [ ] Understand installation method (npm vs pip)
- [ ] Note version detection pattern
- [ ] Check for MCP support requirements
- [ ] Identify any special configuration needs

### Step 1: Add Tool Configuration
**File**: `src/shared/types/cli-tools.ts`

```typescript
export const CLI_TOOLS_REGISTRY: CliToolsRegistry = {
  'gemini-cli': {
    id: 'gemini-cli',
    name: 'Gemini CLI',
    description: 'Google\'s free AI coding assistant with 1M token context',
    command: 'gemini',
    installCommand: 'npm install -g @google/gemini-cli',
    updateCommand: 'npm update -g @google/gemini-cli',
    versionCommand: 'gemini --version',
    versionRegex: /(?:gemini-cli\/|v?)(\d+\.\d+\.\d+)/,
    docsUrl: 'https://cloud.google.com/gemini/docs/codeassist/gemini-cli',
    requiresNode: true
  }
  // ... other tools
};
```

### Step 2: Import Registry at Module Level (CRITICAL!)
**File**: `src/index.ts` (line ~19)

```typescript
// CRITICAL: Import at module level, NOT runtime require()!
import { CLI_TOOLS_REGISTRY } from './shared/types/cli-tools';
```

**WARNING**: Never use `require('./shared/types/cli-tools')` inside handlers - webpack bundling breaks runtime requires!

### Step 3: Implement Install Handler
**File**: `src/index.ts` (~line 1389)

```typescript
ipcMain.handle('cli-tool-install', async (_, toolId: string) => {
  console.log(`[Main] Installing CLI tool: ${toolId}`);
  
  // Use imported registry, not require()
  const toolConfig = CLI_TOOLS_REGISTRY[toolId];
  if (!toolConfig) {
    return { success: false, error: `Unknown tool: ${toolId}` };
  }
  
  if (!toolConfig.installCommand) {
    return { success: false, error: `Installation not available for ${toolConfig.name}` };
  }
  
  try {
    // Execute install command
    const { stdout, stderr } = await execAsync(toolConfig.installCommand, {
      env: { ...process.env, PATH: enhancedPath }
    });
    
    // Verify installation and get version
    const versionResult = await execAsync(toolConfig.versionCommand, {
      env: { ...process.env, PATH: enhancedPath }
    });
    
    // Tool-specific version extraction
    let version = 'Unknown';
    if (toolId === 'gemini-cli') {
      const match = versionResult.stdout.match(/(?:gemini-cli\/|v?)(\d+\.\d+\.\d+)/);
      version = match ? match[1] : 'Unknown';
    }
    
    return { 
      success: true, 
      version,
      message: `${toolConfig.name} installed successfully`
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
});
```

### Step 4: Implement Update Handler
**File**: `src/index.ts` (~line 1492)

```typescript
ipcMain.handle('cli-tool-update', async (_, toolId: string) => {
  const toolConfig = CLI_TOOLS_REGISTRY[toolId];
  
  // Tool-specific version checking
  if (toolId === 'gemini-cli') {
    // Check current version
    const currentVersion = await execAsync('gemini --version');
    // Check latest version
    const latestVersion = await execAsync('npm view @google/gemini-cli version');
    
    if (needsUpdate) {
      await execAsync(toolConfig.updateCommand);
    }
  }
});
```

### Step 5: Implement Configure Handler (MCP Wrapper)
**File**: `src/index.ts` (~line 1625)

```typescript
ipcMain.handle('cli-tool-configure', async (_, toolId: string) => {
  // Generate MCP wrapper dynamically
  const wrapperContent = `#!/bin/bash
# MCP wrapper for ${toolId}
# Auto-generated by Hive Consensus

# Use dynamic tool ID, not hardcoded!
exec npx -y @modelcontextprotocol/${toolId} "$@"
`;
  
  // Write to ~/.hive/mcp/
  const wrapperPath = path.join(os.homedir(), '.hive', 'mcp', `${toolId}-wrapper.sh`);
  await fs.writeFile(wrapperPath, wrapperContent);
  await fs.chmod(wrapperPath, '755');
  
  // Update MCP configuration
  const mcpConfig = {
    "mcpServers": {
      [toolId]: {  // Dynamic key!
        "command": wrapperPath,
        "args": [],
        "env": {}
      }
    }
  };
});
```

### Step 6: Implement Launch Handler
**File**: `src/index.ts` (~line 1849)

```typescript
ipcMain.handle('cli-tool-launch', async (_, toolId: string, projectPath?: string) => {
  const toolConfig = CLI_TOOLS_REGISTRY[toolId];
  
  // Tool-specific launch commands
  let launchCommand = toolConfig.command;
  if (toolId === 'gemini-cli') {
    launchCommand = 'gemini --chat';  // Tool-specific flags
  }
  
  // Create terminal with tool name
  const terminalId = `${toolId}-${Date.now()}`;
  await createTerminal(terminalId, launchCommand, projectPath);
});
```

### Step 7: Add Terminal Display Name
**File**: `src/terminal-ipc-handlers.ts`

```typescript
const TOOL_DISPLAY_NAMES: Record<string, string> = {
  'claude-code': 'Claude',
  'gemini-cli': 'Gemini',  // Add this
  'qwen-code': 'Qwen',
  'aider': 'Aider',
  'cline': 'Cline'
};
```

### Step 8: Create Dynamic Card in Renderer
**File**: `src/renderer.ts` (~line 2286)

```typescript
// Use dynamic detection, NOT static card!
const geminiStatus = await electronAPI.detectCliTool('gemini-cli');
gridContainer.appendChild(createCliToolCard({
  id: 'gemini-cli',
  name: 'Gemini CLI',
  description: 'Google\'s free AI coding assistant with 1M token context',
  status: geminiStatus,
  docsUrl: 'https://cloud.google.com/gemini/docs/codeassist/gemini-cli',
  badgeText: 'FREE',  // Optional badge
  badgeColor: '#28a745'
}));
```

### Step 9: Add Detector Support
**File**: `src/main/cli-tools/detector.ts`

```typescript
// Version detection for each tool
if (tool.id === 'gemini-cli') {
  const match = output.match(/(?:gemini-cli\/|v?)(\d+\.\d+\.\d+)/);
  version = match ? match[1] : null;
}

// MCP support check
result.mcpSupport = await checkMcpSupport(tool.id);
```

## Common Pitfalls to Avoid

### 1. Webpack Bundling Issue (CRITICAL)
```typescript
// ❌ WRONG - Breaks after webpack bundling
ipcMain.handle('cli-tool-install', async (_, toolId) => {
  const { CLI_TOOLS_REGISTRY } = require('./shared/types/cli-tools');
  // This fails in production!
});

// ✅ CORRECT - Import at module level
import { CLI_TOOLS_REGISTRY } from './shared/types/cli-tools';

ipcMain.handle('cli-tool-install', async (_, toolId) => {
  const toolConfig = CLI_TOOLS_REGISTRY[toolId];
  // Works in production!
});
```

### 2. Hardcoded Tool References
```typescript
// ❌ WRONG - Hardcoded tool ID
const mcpConfig = {
  "mcpServers": {
    "claude-code": {  // Hardcoded!
      "command": wrapperPath
    }
  }
};

// ✅ CORRECT - Dynamic tool ID
const mcpConfig = {
  "mcpServers": {
    [toolId]: {  // Dynamic!
      "command": wrapperPath
    }
  }
};
```

### 3. Static vs Dynamic Cards
```typescript
// ❌ WRONG - No functionality
createStaticToolCard('gemini-cli', 'Gemini CLI', ...);

// ✅ CORRECT - Full functionality
const status = await electronAPI.detectCliTool('gemini-cli');
createCliToolCard({ id: 'gemini-cli', status, ... });
```

## Testing Checklist

### Manual Testing Steps
1. **Install Button**
   - Click Install when tool not installed
   - Verify installation progress shown
   - Confirm version displayed after install

2. **Update Button**
   - Click Update when updates available
   - Verify update progress shown
   - Confirm new version displayed

3. **Configure Button**
   - Click Configure to set up MCP
   - Verify wrapper script created
   - Check MCP configuration updated

4. **Launch Button**
   - Click Launch to open terminal
   - Verify terminal opens with tool
   - Confirm tool-specific naming

### Automated Testing
Run the test script:
```bash
node test-gemini-cli.js
```

Should show all green checkmarks:
- ✅ CLI_TOOLS_REGISTRY imported at module level
- ✅ Tool configuration complete
- ✅ All IPC handlers implemented
- ✅ Dynamic card creation
- ✅ Terminal display names
- ✅ MCP wrapper generation

## Applying This Template to New Tools

### For Qwen Code
1. Read `docs/cli-tools/qwen-code.md`
2. Add to `CLI_TOOLS_REGISTRY`:
   ```typescript
   'qwen-code': {
     id: 'qwen-code',
     name: 'Qwen Code',
     command: 'qwen',
     installCommand: 'pip install qwen-code',
     // ... etc
   }
   ```
3. Follow steps 3-9 with Qwen-specific details

### For Aider
1. Read `docs/cli-tools/aider.md`
2. Note: Aider uses pip, has Git integration
3. Add special handling for Git features
4. Follow the complete pattern

### For Each New Tool
1. **Always** start with Step 0 (read docs)
2. **Never** skip the module-level import
3. **Always** use dynamic tool IDs
4. **Always** test all four buttons
5. **Always** verify with test script

## Summary

This Gemini CLI implementation is the definitive template because:
1. It exposed and fixed the webpack bundling issue
2. It implements all four buttons completely
3. It handles MCP integration properly
4. It uses dynamic detection
5. It's been fully tested

Use this exact pattern for all remaining AI CLI tools to ensure consistent, working implementations.