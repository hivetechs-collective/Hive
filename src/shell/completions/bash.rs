// Professional Bash Completions for Hive AI
// Advanced context-aware completions with dynamic suggestions

/// Generate comprehensive bash completions for Hive AI
pub fn generate_bash_completions() -> String {
    r#"# Bash completion for Hive AI
# Generated by Hive AI Shell Integration
# Professional-grade completions with context awareness

_hive_completion() {
    local cur prev opts base
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Global options available for all commands
    local global_opts="-h --help -V --version -v --verbose -q --quiet --format --no-color -c --config"

    # Main commands
    local commands="analyze ask consensus plan execute improve search memory analytics tool serve index config trust hooks interactive tui status completion self-update shell"

    # Handle subcommands based on previous word
    case "${prev}" in
        hive)
            COMPREPLY=( $(compgen -W "${commands}" -- ${cur}) )
            return 0
            ;;
        analyze|a)
            local analyze_opts="--depth --focus --output --dependencies --recommendations --format --no-recommendations --include-tests --exclude-patterns"
            local analyze_values="--depth=quick --depth=standard --depth=comprehensive --focus=architecture --focus=quality --focus=security --focus=performance"
            case "${cur}" in
                --depth=*)
                    COMPREPLY=( $(compgen -W "quick standard comprehensive" -- ${cur#--depth=}) )
                    return 0
                    ;;
                --focus=*)
                    COMPREPLY=( $(compgen -W "architecture quality security performance dependencies patterns" -- ${cur#--focus=}) )
                    return 0
                    ;;
                --*)
                    COMPREPLY=( $(compgen -W "${analyze_opts}" -- ${cur}) )
                    return 0
                    ;;
                *)
                    # Directory completion for analyze target
                    COMPREPLY=( $(compgen -d -- ${cur}) )
                    return 0
                    ;;
            esac
            ;;
        ask|q)
            local ask_opts="--profile --plan --context --max-tokens --stream --no-stream --model --temperature --format"
            case "${cur}" in
                --profile=*)
                    COMPREPLY=( $(compgen -W "speed balanced cost elite" -- ${cur#--profile=}) )
                    return 0
                    ;;
                --model=*)
                    # Dynamic model completion - could be enhanced with actual model list
                    COMPREPLY=( $(compgen -W "gpt-4 claude-3-opus gpt-3.5-turbo claude-3-sonnet" -- ${cur#--model=}) )
                    return 0
                    ;;
                --*)
                    COMPREPLY=( $(compgen -W "${ask_opts}" -- ${cur}) )
                    return 0
                    ;;
                *)
                    # For questions, don't provide file completion
                    return 0
                    ;;
            esac
            ;;
        consensus|con)
            local consensus_opts="--profile --question --output --stream --format --stages --detailed"
            case "${cur}" in
                --profile=*)
                    COMPREPLY=( $(compgen -W "Consensus_Elite Consensus_Balanced Consensus_Speed Consensus_Cost" -- ${cur#--profile=}) )
                    return 0
                    ;;
                --stages=*)
                    COMPREPLY=( $(compgen -W "generator refiner validator curator all" -- ${cur#--stages=}) )
                    return 0
                    ;;
                --*)
                    COMPREPLY=( $(compgen -W "${consensus_opts}" -- ${cur}) )
                    return 0
                    ;;
            esac
            ;;
        plan|p)
            local plan_opts="--complexity --timeline --resources --dependencies --output --interactive --template"
            case "${cur}" in
                --complexity=*)
                    COMPREPLY=( $(compgen -W "simple moderate complex enterprise" -- ${cur#--complexity=}) )
                    return 0
                    ;;
                --timeline=*)
                    COMPREPLY=( $(compgen -W "immediate short-term medium-term long-term" -- ${cur#--timeline=}) )
                    return 0
                    ;;
                --template=*)
                    COMPREPLY=( $(compgen -W "feature bugfix refactor migration optimization" -- ${cur#--template=}) )
                    return 0
                    ;;
                --*)
                    COMPREPLY=( $(compgen -W "${plan_opts}" -- ${cur}) )
                    return 0
                    ;;
            esac
            ;;
        completion|comp)
            local completion_opts="--output --install --shell"
            case "${cur}" in
                --shell=*)
                    COMPREPLY=( $(compgen -W "bash zsh fish powershell elvish" -- ${cur#--shell=}) )
                    return 0
                    ;;
                --*)
                    COMPREPLY=( $(compgen -W "${completion_opts}" -- ${cur}) )
                    return 0
                    ;;
                *)
                    COMPREPLY=( $(compgen -W "bash zsh fish powershell elvish install status" -- ${cur}) )
                    return 0
                    ;;
            esac
            ;;
        config|cfg)
            local config_opts="show set get validate reset edit export import list"
            case "${prev}" in
                set)
                    # Common config keys
                    COMPREPLY=( $(compgen -W "openrouter.api_key cloudflare.d1_id cloudflare.gateway_url default_profile logging.level cache.enabled" -- ${cur}) )
                    return 0
                    ;;
                get)
                    COMPREPLY=( $(compgen -W "openrouter.api_key cloudflare.d1_id default_profile logging.level" -- ${cur}) )
                    return 0
                    ;;
                export|import)
                    COMPREPLY=( $(compgen -f -- ${cur}) )
                    return 0
                    ;;
                *)
                    COMPREPLY=( $(compgen -W "${config_opts}" -- ${cur}) )
                    return 0
                    ;;
            esac
            ;;
        memory|mem)
            local memory_opts="search stats export import clear knowledge conversations analytics"
            case "${prev}" in
                export|import)
                    COMPREPLY=( $(compgen -f -- ${cur}) )
                    return 0
                    ;;
                search)
                    # No specific completion for search terms
                    return 0
                    ;;
                *)
                    COMPREPLY=( $(compgen -W "${memory_opts}" -- ${cur}) )
                    return 0
                    ;;
            esac
            ;;
        analytics|ana)
            local analytics_opts="usage performance cost quality report trends dashboard export"
            case "${prev}" in
                export)
                    COMPREPLY=( $(compgen -f -- ${cur}) )
                    return 0
                    ;;
                report)
                    COMPREPLY=( $(compgen -W "executive operational performance cost quality" -- ${cur}) )
                    return 0
                    ;;
                *)
                    COMPREPLY=( $(compgen -W "${analytics_opts}" -- ${cur}) )
                    return 0
                    ;;
            esac
            ;;
        trust|tr)
            local trust_opts="list add remove clear check security import export status audit"
            case "${prev}" in
                add|remove|check)
                    COMPREPLY=( $(compgen -d -- ${cur}) )
                    return 0
                    ;;
                import|export)
                    COMPREPLY=( $(compgen -f -- ${cur}) )
                    return 0
                    ;;
                *)
                    COMPREPLY=( $(compgen -W "${trust_opts}" -- ${cur}) )
                    return 0
                    ;;
            esac
            ;;
        hooks|hook)
            local hooks_opts="list add remove toggle test validate history config approval workflow"
            case "${prev}" in
                add|remove|toggle|test)
                    # Hook names completion would be dynamic
                    return 0
                    ;;
                *)
                    COMPREPLY=( $(compgen -W "${hooks_opts}" -- ${cur}) )
                    return 0
                    ;;
            esac
            ;;
        shell|sh)
            local shell_opts="install setup status completions uninstall"
            case "${prev}" in
                install|completions)
                    COMPREPLY=( $(compgen -W "bash zsh fish powershell elvish all" -- ${cur}) )
                    return 0
                    ;;
                uninstall)
                    COMPREPLY=( $(compgen -W "bash zsh fish powershell elvish all --preserve-config" -- ${cur}) )
                    return 0
                    ;;
                *)
                    COMPREPLY=( $(compgen -W "${shell_opts}" -- ${cur}) )
                    return 0
                    ;;
            esac
            ;;
        self-update|update)
            local update_opts="--check-only --force --version --rollback --list-versions --channel"
            case "${cur}" in
                --channel=*)
                    COMPREPLY=( $(compgen -W "stable beta nightly" -- ${cur#--channel=}) )
                    return 0
                    ;;
                --*)
                    COMPREPLY=( $(compgen -W "${update_opts}" -- ${cur}) )
                    return 0
                    ;;
            esac
            ;;
        # Global option value completions
        --format)
            COMPREPLY=( $(compgen -W "text json yaml markdown table" -- ${cur}) )
            return 0
            ;;
        --profile)
            COMPREPLY=( $(compgen -W "speed balanced cost elite" -- ${cur}) )
            return 0
            ;;
        --config|-c)
            COMPREPLY=( $(compgen -f -- ${cur}) )
            return 0
            ;;
        --output|-o)
            COMPREPLY=( $(compgen -f -- ${cur}) )
            return 0
            ;;
    esac

    # Handle flag-like options
    case "${cur}" in
        -*)
            COMPREPLY=( $(compgen -W "${global_opts}" -- ${cur}) )
            return 0
            ;;
        *)
            # Default to command completion
            COMPREPLY=( $(compgen -W "${commands}" -- ${cur}) )
            return 0
            ;;
    esac
}

# Smart context-aware completion enhancement
_hive_smart_complete() {
    local current_dir=$(pwd)
    local context_suggestions=""

    # Detect project context and add relevant suggestions
    if [[ -d ".git" ]]; then
        context_suggestions="$context_suggestions git-analyze git-status"
    fi

    if [[ -f "Cargo.toml" ]]; then
        context_suggestions="$context_suggestions rust-check rust-test rust-build"
    fi

    if [[ -f "package.json" ]]; then
        context_suggestions="$context_suggestions npm-audit js-analyze node-deps"
    fi

    if [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]]; then
        context_suggestions="$context_suggestions python-deps py-analyze venv-check"
    fi

    if [[ -f "go.mod" ]]; then
        context_suggestions="$context_suggestions go-mod go-analyze go-deps"
    fi

    # Add context suggestions to completions if any detected
    if [[ -n "$context_suggestions" ]]; then
        COMPREPLY=( "${COMPREPLY[@]}" $(compgen -W "$context_suggestions" -- ${COMP_WORDS[COMP_CWORD]}) )
    fi
}

# Advanced file type aware completion
_hive_file_context() {
    local current_word="${COMP_WORDS[COMP_CWORD]}"
    local file_suggestions=""

    # Suggest relevant files based on command context
    case "${COMP_WORDS[1]}" in
        analyze)
            # Prefer directories and common project files
            file_suggestions=$(find . -maxdepth 2 -type d -name "src" -o -name "lib" -o -name "app" 2>/dev/null | head -10)
            ;;
        improve)
            # Suggest source files
            file_suggestions=$(find . -maxdepth 3 \( -name "*.rs" -o -name "*.ts" -o -name "*.js" -o -name "*.py" -o -name "*.go" \) 2>/dev/null | head -20)
            ;;
    esac

    if [[ -n "$file_suggestions" ]]; then
        COMPREPLY=( "${COMPREPLY[@]}" $(compgen -W "$file_suggestions" -- $current_word) )
    fi
}

# Register the main completion function
complete -F _hive_completion hive

# Register smart completions for common aliases
complete -F _hive_completion ha h
complete -F _hive_completion hive-ask hq
complete -F _hive_completion hive-analyze
complete -F _hive_completion hive-plan hp

# Professional aliases with descriptions
alias ha='hive analyze'
alias hq='hive ask'
alias hp='hive plan'
alias hs='hive search'
alias hm='hive memory search'
alias ht='hive trust check .'
alias hc='hive config show'
alias hst='hive status'
alias htui='hive tui'

# Advanced aliases for power users
alias hive-quick='hive ask --profile=speed'
alias hive-best='hive ask --profile=elite'
alias hive-cheap='hive ask --profile=cost'
alias hive-here='hive analyze . --depth=standard'
alias hive-full='hive analyze . --depth=comprehensive --dependencies --recommendations'
alias hive-check='hive trust check . && hive status'

# Shell functions for enhanced workflow
hive_quick_ask() {
    if [[ $# -eq 0 ]]; then
        echo "Usage: hive_quick_ask <question>"
        return 1
    fi
    hive ask "$*" --profile=speed --stream
}

hive_analyze_current() {
    local depth="${1:-standard}"
    hive analyze . --depth="$depth" --recommendations --format=text
}

hive_plan_feature() {
    if [[ $# -eq 0 ]]; then
        echo "Usage: hive_plan_feature <feature_description>"
        return 1
    fi
    hive plan "$*" --template=feature --interactive
}

hive_memory_find() {
    if [[ $# -eq 0 ]]; then
        echo "Usage: hive_memory_find <search_term>"
        return 1
    fi
    hive memory search "$*" --format=table --limit=10
}

# Export functions for use in scripts
export -f hive_quick_ask
export -f hive_analyze_current
export -f hive_plan_feature
export -f hive_memory_find

# Helpful environment variables
export HIVE_DEFAULT_PROFILE="balanced"
export HIVE_DEFAULT_FORMAT="text"
export HIVE_AUTO_TRUST_CURRENT="false"

# Context detection for better UX
_hive_detect_context() {
    local context=""

    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        context="git"
    fi

    if [[ -f "Cargo.toml" ]]; then
        context="$context rust"
    fi

    if [[ -f "package.json" ]]; then
        context="$context javascript"
    fi

    if [[ -f "requirements.txt" || -f "pyproject.toml" ]]; then
        context="$context python"
    fi

    export HIVE_CONTEXT="$context"
}

# Auto-detect context when changing directories
if [[ "$PROMPT_COMMAND" != *"_hive_detect_context"* ]]; then
    PROMPT_COMMAND="_hive_detect_context; $PROMPT_COMMAND"
fi

# Professional command not found handler
command_not_found_handle() {
    local command="$1"

    # Suggest hive commands for common typos
    case "$command" in
        hiv|hive-*)
            echo "Command '$command' not found. Did you mean 'hive'?"
            echo "Try: hive --help"
            return 127
            ;;
        analyize|analze)
            echo "Command '$command' not found. Did you mean 'hive analyze'?"
            return 127
            ;;
        *)
            echo "bash: $command: command not found"
            return 127
            ;;
    esac
}

echo "✅ Hive AI Bash completions loaded successfully"
echo "💡 Try: hive <TAB> or use aliases: ha, hq, hp, hs, hm, ht"
echo "🔍 Use 'hive --help' for full command reference"
"#.to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bash_completions_generation() {
        let completions = generate_bash_completions();

        // Basic structure checks
        assert!(completions.contains("_hive_completion"));
        assert!(completions.contains("complete -F _hive_completion hive"));

        // Check for main commands
        assert!(completions.contains("analyze"));
        assert!(completions.contains("ask"));
        assert!(completions.contains("consensus"));
        assert!(completions.contains("plan"));

        // Check for aliases
        assert!(completions.contains("alias ha='hive analyze'"));
        assert!(completions.contains("alias hq='hive ask'"));

        // Check for smart functions
        assert!(completions.contains("hive_quick_ask"));
        assert!(completions.contains("_hive_detect_context"));
    }

    #[test]
    fn test_bash_completions_contains_all_shells() {
        let completions = generate_bash_completions();

        // Should support all shell types in completion command
        assert!(completions.contains("bash zsh fish powershell elvish"));
    }
}
