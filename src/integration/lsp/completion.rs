//! AI-powered code completion
//!
//! Provides intelligent code completion using consensus engine and semantic analysis

use super::protocol::*;
use crate::core::{HiveError, Result};
use crate::consensus::ConsensusEngine;
use crate::analysis::AnalysisEngine;

use std::sync::Arc;
use tokio::sync::RwLock;
use serde_json::Value;
use tracing::{info, debug, error, warn};
use std::time::Instant;

/// AI-powered completion provider
pub struct AiCompletionProvider {
    consensus_engine: Arc<RwLock<ConsensusEngine>>,
    analysis_engine: Arc<AnalysisEngine>,
    config: CompletionConfig,
}

/// Completion configuration
#[derive(Debug, Clone)]
pub struct CompletionConfig {
    /// Maximum number of completion items to return
    pub max_items: usize,
    /// Response timeout in milliseconds
    pub timeout_ms: u64,
    /// Enable AI-powered suggestions
    pub ai_suggestions: bool,
    /// Enable context-aware completion
    pub context_aware: bool,
    /// Enable snippet completion
    pub snippets: bool,
    /// Enable import suggestions
    pub import_suggestions: bool,
    /// Performance tracking
    pub track_performance: bool,
}

impl Default for CompletionConfig {
    fn default() -> Self {
        Self {
            max_items: 50,
            timeout_ms: 500,
            ai_suggestions: true,
            context_aware: true,
            snippets: true,
            import_suggestions: true,
            track_performance: false,
        }
    }
}

/// Completion context
#[derive(Debug, Clone)]
pub struct CompletionContext {
    pub document_uri: String,
    pub position: Position,
    pub text_before_cursor: String,
    pub text_after_cursor: String,
    pub current_line: String,
    pub language: String,
    pub surrounding_context: String,
    pub trigger_character: Option<String>,
}\n\n/// Completion item with AI metadata\n#[derive(Debug, Clone)]\npub struct AiCompletionItem {\n    pub base: CompletionItem,\n    pub confidence: f64,\n    pub ai_generated: bool,\n    pub context_relevance: f64,\n    pub usage_frequency: Option<f64>,\n}\n\nimpl AiCompletionProvider {\n    /// Create new AI completion provider\n    pub async fn new(\n        consensus_engine: Arc<RwLock<ConsensusEngine>>,\n        analysis_engine: Arc<AnalysisEngine>,\n        config: Option<CompletionConfig>,\n    ) -> Result<Self> {\n        Ok(Self {\n            consensus_engine,\n            analysis_engine,\n            config: config.unwrap_or_default(),\n        })\n    }\n\n    /// Provide completion suggestions\n    pub async fn provide_completion(\n        &self,\n        params: &TextDocumentPositionParams,\n        document_content: &str,\n        trigger_character: Option<String>,\n    ) -> Result<CompletionList> {\n        let start_time = if self.config.track_performance { \n            Some(Instant::now()) \n        } else { \n            None \n        };\n\n        debug!(\n            \"Providing completion at {}:{} in {}\",\n            params.position.line, params.position.character, params.text_document.uri\n        );\n\n        // Build completion context\n        let context = self.build_completion_context(\n            params,\n            document_content,\n            trigger_character,\n        ).await?;\n\n        // Get completions from multiple sources\n        let mut completion_items = Vec::new();\n\n        // 1. Syntax-aware completions\n        let syntax_completions = self.get_syntax_completions(&context).await?;\n        completion_items.extend(syntax_completions);\n\n        // 2. AI-powered completions\n        if self.config.ai_suggestions {\n            let ai_completions = self.get_ai_completions(&context).await?;\n            completion_items.extend(ai_completions);\n        }\n\n        // 3. Context-aware completions\n        if self.config.context_aware {\n            let context_completions = self.get_context_completions(&context).await?;\n            completion_items.extend(context_completions);\n        }\n\n        // 4. Snippet completions\n        if self.config.snippets {\n            let snippet_completions = self.get_snippet_completions(&context).await?;\n            completion_items.extend(snippet_completions);\n        }\n\n        // 5. Import suggestions\n        if self.config.import_suggestions {\n            let import_completions = self.get_import_completions(&context).await?;\n            completion_items.extend(import_completions);\n        }\n\n        // Sort by relevance and confidence\n        completion_items.sort_by(|a, b| {\n            let score_a = a.confidence * a.context_relevance;\n            let score_b = b.confidence * b.context_relevance;\n            score_b.partial_cmp(&score_a).unwrap_or(std::cmp::Ordering::Equal)\n        });\n\n        // Limit results\n        completion_items.truncate(self.config.max_items);\n\n        // Convert to LSP format\n        let items: Vec<CompletionItem> = completion_items\n            .into_iter()\n            .map(|item| item.base)\n            .collect();\n\n        let completion_list = CompletionList {\n            is_incomplete: items.len() >= self.config.max_items,\n            items,\n        };\n\n        if let Some(start) = start_time {\n            debug!(\n                \"Completion request processed in {:?} ({} items)\",\n                start.elapsed(),\n                completion_list.items.len()\n            );\n        }\n\n        Ok(completion_list)\n    }\n\n    /// Build completion context\n    async fn build_completion_context(\n        &self,\n        params: &TextDocumentPositionParams,\n        document_content: &str,\n        trigger_character: Option<String>,\n    ) -> Result<CompletionContext> {\n        let lines: Vec<&str> = document_content.lines().collect();\n        let current_line_idx = params.position.line as usize;\n        let current_char_idx = params.position.character as usize;\n\n        let current_line = if current_line_idx < lines.len() {\n            lines[current_line_idx].to_string()\n        } else {\n            String::new()\n        };\n\n        let text_before_cursor = if current_line_idx < lines.len() {\n            let line = lines[current_line_idx];\n            if current_char_idx <= line.len() {\n                line[..current_char_idx].to_string()\n            } else {\n                line.to_string()\n            }\n        } else {\n            String::new()\n        };\n\n        let text_after_cursor = if current_line_idx < lines.len() {\n            let line = lines[current_line_idx];\n            if current_char_idx < line.len() {\n                line[current_char_idx..].to_string()\n            } else {\n                String::new()\n            }\n        } else {\n            String::new()\n        };\n\n        // Build surrounding context (5 lines before and after)\n        let context_start = current_line_idx.saturating_sub(5);\n        let context_end = std::cmp::min(current_line_idx + 6, lines.len());\n        let surrounding_context = lines[context_start..context_end].join(\"\\n\");\n\n        // Detect language from URI\n        let language = self.detect_language(&params.text_document.uri);\n\n        Ok(CompletionContext {\n            document_uri: params.text_document.uri.clone(),\n            position: params.position.clone(),\n            text_before_cursor,\n            text_after_cursor,\n            current_line,\n            language,\n            surrounding_context,\n            trigger_character,\n        })\n    }\n\n    /// Get syntax-aware completions\n    async fn get_syntax_completions(&self, context: &CompletionContext) -> Result<Vec<AiCompletionItem>> {\n        debug!(\"Getting syntax completions for {}\", context.language);\n\n        let mut completions = Vec::new();\n\n        // Parse the document to get AST\n        let parse_result = self.analysis_engine.parse_code(&context.surrounding_context, Some(&context.language)).await?;\n\n        // Extract symbols from AST\n        for symbol in parse_result.symbols {\n            let completion_item = CompletionItem {\n                label: symbol.name.clone(),\n                kind: Some(self.symbol_kind_to_completion_kind(&symbol.kind)),\n                detail: Some(format!(\"{} {}\", symbol.kind, symbol.name)),\n                documentation: symbol.documentation.map(|doc| MarkupContent {\n                    kind: MarkupKind::Markdown,\n                    value: doc,\n                }),\n                insert_text: Some(symbol.name.clone()),\n                insert_text_format: Some(InsertTextFormat::PlainText),\n                text_edit: None,\n                additional_text_edits: None,\n            };\n\n            completions.push(AiCompletionItem {\n                base: completion_item,\n                confidence: 0.8,\n                ai_generated: false,\n                context_relevance: self.calculate_symbol_relevance(&symbol, context),\n                usage_frequency: None,\n            });\n        }\n\n        Ok(completions)\n    }\n\n    /// Get AI-powered completions\n    async fn get_ai_completions(&self, context: &CompletionContext) -> Result<Vec<AiCompletionItem>> {\n        debug!(\"Getting AI completions\");\n\n        let consensus = self.consensus_engine.read().await;\n        \n        let completion_prompt = format!(\n            \"Complete this {} code. Provide only the completion text, no explanations.\\n\\nContext:\\n```{}\\n{}```\\n\\nCursor is at the end of the last line. Provide 3-5 most likely completions:\",\n            context.language,\n            context.surrounding_context,\n            context.text_before_cursor\n        );\n\n        match consensus.ask(&completion_prompt).await {\n            Ok(response) => {\n                let suggestions = self.parse_ai_suggestions(&response.content);\n                Ok(suggestions.into_iter().map(|suggestion| {\n                    AiCompletionItem {\n                        base: CompletionItem {\n                            label: suggestion.label.clone(),\n                            kind: Some(CompletionItemKind::Text),\n                            detail: Some(\"AI Suggestion\".to_string()),\n                            documentation: Some(MarkupContent {\n                                kind: MarkupKind::Markdown,\n                                value: \"AI-generated completion based on context analysis\".to_string(),\n                            }),\n                            insert_text: Some(suggestion.text),\n                            insert_text_format: Some(InsertTextFormat::PlainText),\n                            text_edit: None,\n                            additional_text_edits: None,\n                        },\n                        confidence: suggestion.confidence,\n                        ai_generated: true,\n                        context_relevance: suggestion.relevance,\n                        usage_frequency: None,\n                    }\n                }).collect())\n            }\n            Err(e) => {\n                warn!(\"AI completion failed: {}\", e);\n                Ok(Vec::new())\n            }\n        }\n    }\n\n    /// Get context-aware completions\n    async fn get_context_completions(&self, context: &CompletionContext) -> Result<Vec<AiCompletionItem>> {\n        debug!(\"Getting context-aware completions\");\n\n        let mut completions = Vec::new();\n\n        // Analyze the trigger character and context\n        if let Some(trigger) = &context.trigger_character {\n            match trigger.as_str() {\n                \".\" => {\n                    // Method/property completion\n                    completions.extend(self.get_member_completions(context).await?);\n                }\n                \"::\" => {\n                    // Namespace/static member completion\n                    completions.extend(self.get_namespace_completions(context).await?);\n                }\n                \"(\" => {\n                    // Function parameter completion\n                    completions.extend(self.get_parameter_completions(context).await?);\n                }\n                _ => {}\n            }\n        }\n\n        // Add common patterns based on context\n        if context.text_before_cursor.trim().ends_with(\"if\") {\n            completions.push(self.create_pattern_completion(\n                \"if condition\",\n                \"if (${1:condition}) {\\n    ${2:body}\\n}\",\n                \"Control flow if statement\",\n            ));\n        }\n\n        if context.text_before_cursor.trim().ends_with(\"for\") {\n            completions.push(self.create_pattern_completion(\n                \"for loop\",\n                \"for (${1:init}; ${2:condition}; ${3:increment}) {\\n    ${4:body}\\n}\",\n                \"Control flow for loop\",\n            ));\n        }\n\n        Ok(completions)\n    }\n\n    /// Get snippet completions\n    async fn get_snippet_completions(&self, context: &CompletionContext) -> Result<Vec<AiCompletionItem>> {\n        debug!(\"Getting snippet completions\");\n\n        let mut completions = Vec::new();\n\n        // Language-specific snippets\n        match context.language.as_str() {\n            \"rust\" => {\n                completions.extend(self.get_rust_snippets());\n            }\n            \"javascript\" | \"typescript\" => {\n                completions.extend(self.get_js_snippets());\n            }\n            \"python\" => {\n                completions.extend(self.get_python_snippets());\n            }\n            _ => {}\n        }\n\n        Ok(completions)\n    }\n\n    /// Get import suggestions\n    async fn get_import_completions(&self, context: &CompletionContext) -> Result<Vec<AiCompletionItem>> {\n        debug!(\"Getting import completions\");\n\n        let mut completions = Vec::new();\n\n        // Analyze what might need to be imported\n        if let Some(undefined_symbol) = self.extract_undefined_symbol(context) {\n            // Use AI to suggest imports\n            let import_suggestions = self.suggest_imports(&undefined_symbol, &context.language).await?;\n            completions.extend(import_suggestions);\n        }\n\n        Ok(completions)\n    }\n\n    /// Get member completions (after \".\")\n    async fn get_member_completions(&self, context: &CompletionContext) -> Result<Vec<AiCompletionItem>> {\n        // TODO: Implement member completion based on type analysis\n        Ok(vec![\n            self.create_pattern_completion(\n                \"length\",\n                \"length\",\n                \"Get the length of the collection\",\n            ),\n            self.create_pattern_completion(\n                \"toString()\",\n                \"toString()\",\n                \"Convert to string representation\",\n            ),\n        ])\n    }\n\n    /// Get namespace completions (after \"::\")\n    async fn get_namespace_completions(&self, context: &CompletionContext) -> Result<Vec<AiCompletionItem>> {\n        // TODO: Implement namespace completion\n        Ok(Vec::new())\n    }\n\n    /// Get parameter completions (after \"(\")\n    async fn get_parameter_completions(&self, context: &CompletionContext) -> Result<Vec<AiCompletionItem>> {\n        // TODO: Implement parameter completion with signature help\n        Ok(Vec::new())\n    }\n\n    /// Create pattern completion\n    fn create_pattern_completion(&self, label: &str, snippet: &str, description: &str) -> AiCompletionItem {\n        AiCompletionItem {\n            base: CompletionItem {\n                label: label.to_string(),\n                kind: Some(CompletionItemKind::Snippet),\n                detail: Some(description.to_string()),\n                documentation: Some(MarkupContent {\n                    kind: MarkupKind::Markdown,\n                    value: format!(\"Pattern: `{}`\\n\\n{}\", label, description),\n                }),\n                insert_text: Some(snippet.to_string()),\n                insert_text_format: Some(InsertTextFormat::Snippet),\n                text_edit: None,\n                additional_text_edits: None,\n            },\n            confidence: 0.7,\n            ai_generated: false,\n            context_relevance: 0.8,\n            usage_frequency: None,\n        }\n    }\n\n    /// Get Rust-specific snippets\n    fn get_rust_snippets(&self) -> Vec<AiCompletionItem> {\n        vec![\n            self.create_pattern_completion(\n                \"fn\",\n                \"fn ${1:name}(${2:params}) -> ${3:ReturnType} {\\n    ${4:body}\\n}\",\n                \"Function definition\",\n            ),\n            self.create_pattern_completion(\n                \"impl\",\n                \"impl ${1:Type} {\\n    ${2:methods}\\n}\",\n                \"Implementation block\",\n            ),\n            self.create_pattern_completion(\n                \"match\",\n                \"match ${1:expr} {\\n    ${2:pattern} => ${3:result},\\n}\",\n                \"Match expression\",\n            ),\n        ]\n    }\n\n    /// Get JavaScript/TypeScript snippets\n    fn get_js_snippets(&self) -> Vec<AiCompletionItem> {\n        vec![\n            self.create_pattern_completion(\n                \"function\",\n                \"function ${1:name}(${2:params}) {\\n    ${3:body}\\n}\",\n                \"Function declaration\",\n            ),\n            self.create_pattern_completion(\n                \"arrow\",\n                \"(${1:params}) => {\\n    ${2:body}\\n}\",\n                \"Arrow function\",\n            ),\n            self.create_pattern_completion(\n                \"class\",\n                \"class ${1:Name} {\\n    constructor(${2:params}) {\\n        ${3:body}\\n    }\\n}\",\n                \"Class definition\",\n            ),\n        ]\n    }\n\n    /// Get Python snippets\n    fn get_python_snippets(&self) -> Vec<AiCompletionItem> {\n        vec![\n            self.create_pattern_completion(\n                \"def\",\n                \"def ${1:name}(${2:params}):\\n    ${3:body}\",\n                \"Function definition\",\n            ),\n            self.create_pattern_completion(\n                \"class\",\n                \"class ${1:Name}:\\n    def __init__(self, ${2:params}):\\n        ${3:body}\",\n                \"Class definition\",\n            ),\n            self.create_pattern_completion(\n                \"if\",\n                \"if ${1:condition}:\\n    ${2:body}\",\n                \"If statement\",\n            ),\n        ]\n    }\n\n    /// Parse AI suggestions from response\n    fn parse_ai_suggestions(&self, content: &str) -> Vec<AiSuggestion> {\n        // Simple parsing - in practice, this would be more sophisticated\n        let mut suggestions = Vec::new();\n        \n        for (i, line) in content.lines().enumerate() {\n            if !line.trim().is_empty() && i < 5 {\n                suggestions.push(AiSuggestion {\n                    label: line.trim().to_string(),\n                    text: line.trim().to_string(),\n                    confidence: 0.8 - (i as f64 * 0.1),\n                    relevance: 0.9 - (i as f64 * 0.1),\n                });\n            }\n        }\n        \n        suggestions\n    }\n\n    /// Extract undefined symbol from context\n    fn extract_undefined_symbol(&self, context: &CompletionContext) -> Option<String> {\n        // Simple extraction - look for word before cursor\n        let words: Vec<&str> = context.text_before_cursor.split_whitespace().collect();\n        words.last().map(|s| s.to_string())\n    }\n\n    /// Suggest imports for undefined symbol\n    async fn suggest_imports(&self, symbol: &str, language: &str) -> Result<Vec<AiCompletionItem>> {\n        // TODO: Implement import suggestion using AI\n        debug!(\"Suggesting imports for {} in {}\", symbol, language);\n        Ok(Vec::new())\n    }\n\n    /// Convert symbol kind to completion kind\n    fn symbol_kind_to_completion_kind(&self, symbol_kind: &str) -> CompletionItemKind {\n        match symbol_kind {\n            \"function\" => CompletionItemKind::Function,\n            \"method\" => CompletionItemKind::Method,\n            \"class\" => CompletionItemKind::Class,\n            \"interface\" => CompletionItemKind::Interface,\n            \"variable\" => CompletionItemKind::Variable,\n            \"constant\" => CompletionItemKind::Constant,\n            \"property\" => CompletionItemKind::Property,\n            \"field\" => CompletionItemKind::Field,\n            \"enum\" => CompletionItemKind::Enum,\n            \"module\" => CompletionItemKind::Module,\n            \"keyword\" => CompletionItemKind::Keyword,\n            _ => CompletionItemKind::Text,\n        }\n    }\n\n    /// Calculate symbol relevance to context\n    fn calculate_symbol_relevance(&self, symbol: &crate::analysis::Symbol, context: &CompletionContext) -> f64 {\n        let mut relevance = 0.5;\n        \n        // Boost relevance if symbol is used nearby\n        if context.surrounding_context.contains(&symbol.name) {\n            relevance += 0.3;\n        }\n        \n        // Boost relevance if symbol is in current scope\n        if let Some(scope) = &symbol.scope {\n            if context.surrounding_context.contains(scope) {\n                relevance += 0.2;\n            }\n        }\n        \n        relevance.min(1.0)\n    }\n\n    /// Detect language from file URI\n    fn detect_language(&self, uri: &str) -> String {\n        if let Some(ext) = uri.split('.').last() {\n            match ext {\n                \"rs\" => \"rust\".to_string(),\n                \"js\" => \"javascript\".to_string(),\n                \"ts\" => \"typescript\".to_string(),\n                \"py\" => \"python\".to_string(),\n                \"java\" => \"java\".to_string(),\n                \"cpp\" | \"cc\" | \"cxx\" => \"cpp\".to_string(),\n                \"c\" => \"c\".to_string(),\n                \"go\" => \"go\".to_string(),\n                \"rb\" => \"ruby\".to_string(),\n                \"php\" => \"php\".to_string(),\n                \"swift\" => \"swift\".to_string(),\n                \"kt\" => \"kotlin\".to_string(),\n                \"cs\" => \"csharp\".to_string(),\n                _ => \"plaintext\".to_string(),\n            }\n        } else {\n            \"plaintext\".to_string()\n        }\n    }\n}\n\n/// AI suggestion\n#[derive(Debug, Clone)]\nstruct AiSuggestion {\n    label: String,\n    text: String,\n    confidence: f64,\n    relevance: f64,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_language_detection() {\n        let provider = AiCompletionProvider {\n            consensus_engine: Arc::new(RwLock::new(ConsensusEngine::default())),\n            analysis_engine: Arc::new(AnalysisEngine::default()),\n            config: CompletionConfig::default(),\n        };\n\n        assert_eq!(provider.detect_language(\"file.rs\"), \"rust\");\n        assert_eq!(provider.detect_language(\"file.js\"), \"javascript\");\n        assert_eq!(provider.detect_language(\"file.py\"), \"python\");\n        assert_eq!(provider.detect_language(\"file.unknown\"), \"plaintext\");\n    }\n\n    #[test]\n    fn test_symbol_kind_conversion() {\n        let provider = AiCompletionProvider {\n            consensus_engine: Arc::new(RwLock::new(ConsensusEngine::default())),\n            analysis_engine: Arc::new(AnalysisEngine::default()),\n            config: CompletionConfig::default(),\n        };\n\n        assert_eq!(\n            provider.symbol_kind_to_completion_kind(\"function\"),\n            CompletionItemKind::Function\n        );\n        assert_eq!(\n            provider.symbol_kind_to_completion_kind(\"class\"),\n            CompletionItemKind::Class\n        );\n        assert_eq!(\n            provider.symbol_kind_to_completion_kind(\"unknown\"),\n            CompletionItemKind::Text\n        );\n    }\n}"